--CANCEL ALL SALES FOR THE ITEM KEY AND LIST OF STORES PASSED IN
CREATE PROCEDURE [dbo].[CancelAllSales]
  @Item_Key int,
  @StoreList varchar(8000),
  @StoreListSeparator char(1),
  @StartDate smalldatetime,  --EFFECTIVE DATE OF CANCELLATION
  @User_ID int,
  @User_ID_Date datetime,
  @ValidationCode int OUTPUT
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @error_no int = 0;
    
  DECLARE @StoreTable table(Store_no int)
	
	--BUILD STORE TABLE FROM PIPE DELIMITED LIST PASSED IN
	INSERT INTO @StoreTable
		SELECT Key_Value FROM dbo.fn_Parse_List(@StoreList, @StoreListSeparator) StoreList
    
	--[STEPS TAKEN FROM TECH SPEC FOR 'END SALE EARLY AND CANCEL ALL SALES' DOCUMENTATION]
	--STEP 1
	--1.	If there are PriceBatchDetail records for the Store/Item with a “Sale” PriceChgTypeID 
	--      assigned to a batch header record and the batch header record is in the Building state, 
	--      the PriceBatchDetail records will be removed from the batch by setting the PriceBatchHeaderID 
	--      in the PriceBatchDetail table to NULL.
	BEGIN
		UPDATE PriceBatchDetail SET PriceBatchHeaderID = NULL
		WHERE PriceBatchDetailID IN (
			SELECT PBD.PriceBatchDetailID
			FROM PriceBatchDetail PBD
			INNER JOIN Item I (nolock) ON PBD.Item_Key = I.Item_Key
			INNER JOIN @StoreTable S ON PBD.Store_No = S.Store_No	
			INNER JOIN PriceChgType PCT (nolock) ON PCT.PriceChgTypeID = PBD.PriceChgTypeID
			INNER JOIN PriceBatchHeader PBH (nolock) ON PBH.PriceBatchHeaderID = PBD.PriceBatchHeaderID
			WHERE I.Item_Key = @Item_Key 
				AND PCT.On_Sale = 1 --SALE BATCH	
				AND PBD.PriceBatchHeaderID IS NOT NULL --ASSIGNED TO A BATCH
				AND PBH.PriceBatchStatusID = 1
				AND Expired <> 1)

		set @error_no = @@ERROR
	END

	--STEP 2
	--2. All PriceBatchDetail records for the Store/Item with a “Sale” PriceChgTypeID will be set to Expired.  
	--   This includes records that have already been batched and sent to the POS, as well as future price changes that are pending in the database.
	IF @error_no = 0
    BEGIN
      if(object_id('tempdb..#pbd') is not null) drop table #pbd; --Temp table to hold data subset.

      select A.* into #pbd
      from PriceBatchDetail A
      inner join Item B (nolock) ON B.Item_Key = A.Item_Key
      inner join @StoreTable C ON C.Store_No = A.Store_No
      where B.Item_Key = @Item_Key and A.Expired <> 1;

    ;with cte as(select top 100 percent PriceBatchDetailID from
                  (--ITEMS THAT HAVE BEEN BATCHED IN SOME STATUS
                   select A.PriceBatchDetailID from #pbd A
                   inner join PriceChgType B (nolock) ON B.PriceChgTypeID = A.PriceChgTypeID
                   inner join PriceBatchHeader C (nolock) ON C.PriceBatchHeaderID = A.PriceBatchHeaderID
                   where B.On_Sale = 1                    --SALE BATCH	
                   	and A.PriceBatchHeaderID is not null  --ASSIGNED TO A BATCH	
                   	and(C.PriceBatchStatusID IN (2,3,4,5) --BATCH NOT YET PROCESSED (STEP 2 CLEANS UP THOSE IN 'BUILDING' STATUS)
                          or(C.PriceBatchStatusID = 6 and cast(A.Sale_End_Date as date) >= cast(@StartDate as date))) --BATCH HAS BEEN PROCESSED AND SALE NOT YET OVER
                   union
                   --EXPIRE ALL PRICE CHANGE RECORDS THAT HAVE NOT YET BEEN BATCHED. INCLUDE ANY AUTO-GENERATED REGs, SINCE THOSE WILL BE REPLACED WITH THE CANCEL REG
                   select PriceBatchDetailID from #pbd
                   where PriceChgTypeID is not null                         --PRICE CHANGES ONLY
                   	 and PriceBatchHeaderID is null                          --NOT YET IN A BATCH
                   	 and cast(StartDate as date) >= cast(StartDate as date) --PENDING RECORD WILL BE AFFECTED BY SALE CANCELLATION STARTDATE
                   	 and (dbo.fn_OnSale(PriceChgTypeId) = 1 or AutoGenerated = 1)
                  ) A group by PriceBatchDetailID
              )

      update A SET Expired = 1, EndedEarly = 1
      from PriceBatchDetail A
      inner join cte B on B.PriceBatchDetailID = A.PriceBatchDetailID

		  set @error_no = @@ERROR
	END
	
	--STEP 3
	--3.	A new PriceBatchDetail record will be generated to send down a “REG” price change, with the start date equal to the 
	--      cancel date specified by the user, to end the ongoing sale for the item.  	
	IF @error_no = 0
    BEGIN
		  declare @CurrentStoreNo int,
              @Price smallmoney,
              @POSPrice smallmoney,
              @Multiple tinyint
		
		--CREATE A CURSOR TO STEP THROUGH EACH STORE IN THE STORE LIST
		-- only for stores that are actually on sale!  Otherwise, no need to insert a new REG price.  
		DECLARE csStores CURSOR
		READ_ONLY
		FOR     
			SELECT ST.Store_No
			FROM @StoreTable ST
			INNER JOIN PRICE P
				ON P.Store_No = ST.Store_No
				AND P.Item_Key = @Item_Key
			WHERE dbo.fn_OnSale(P.PriceChgTypeID) = 1 		
		
		OPEN csStores
	    
		FETCH NEXT FROM csStores INTO @CurrentStoreNo
		WHILE (@@fetch_status <> -1)
		BEGIN
    		IF (@@fetch_status <> -2)
		BEGIN
			--GET THE CURRENT PRICE & MULTIPLE FROM THE PRICE TABLE FOR THIS ITEM
			SELECT @Price = Price, @POSPrice = POSPrice, @Multiple = Multiple 
			FROM Price 
			WHERE Item_Key = @Item_Key 
				AND Store_No = @CurrentStoreNo
	    
	    			-- DON'T INSERT THE CANCEL REG IF THERE'S ALREADY A USER-ENTERED REG CHANGE THERE
			IF NOT EXISTS (SELECT 1 
					FROM PriceBatchDetail 
					WHERE Item_Key = @Item_Key 
					AND Store_No = @CurrentStoreNo
					AND dbo.fn_OnSale(PriceChgTypeId) = 0
					AND AutoGenerated = 0
					AND cast(StartDate as date) = cast(@StartDate as date)
					AND Expired = 0)
				BEGIN
					--INSERT NEW REG PRICE FOR THIS STORE/ITEM
					EXEC UpdatePriceBatchDetailReg @Item_Key, @User_ID, @User_ID_Date, @CurrentStoreNo, @StartDate, 
										   @Multiple, @POSPrice, @Price, NULL, 'IRMA Client', @ValidationCode, 1
				END
		END
    		FETCH NEXT FROM csStores INTO @CurrentStoreNo
		END
	    
		CLOSE csStores
		DEALLOCATE csStores		
   		
		SELECT @error_no = @@ERROR
	END	
	
	--STEP 4
	--4.	When the POS Push process applies the “REG” price change to the Price table, it should change the Sale End Date for 
	--      the ongoing sale to the day before the Start Date of the “REG” price change.
		
	--THIS STEP HANDLED BY POS PROCESS IN THE Replenishment_POSPush_UpdatePriceBatchProcessedChg STORED PROCEDURE
    
    IF @error_no <> 0
    BEGIN
        IF @@TRANCOUNT <> 0
            ROLLBACK TRAN
        DECLARE @Severity smallint
        SELECT @Severity = ISNULL((SELECT severity FROM master.dbo.sysmessages WHERE error = @error_no), 16)
        RAISERROR ('CancelAllSales failed with @@ERROR: %d', @Severity, 1, @error_no)
    END    
    
    if(object_id('tempdb..#pbd') is not null) drop table #pbd;
    SET NOCOUNT OFF
END

GO
GRANT EXECUTE
    ON OBJECT::[dbo].[CancelAllSales] TO [IRMAClientRole]
    AS [dbo];