
CREATE PROCEDURE [dbo].[UpdatePriceBatchDetailReg]
    @Item_Key int,
    @User_ID int,
    @User_ID_Date datetime,
    @Store_No int,
    @StartDate smalldatetime,
    @Multiple tinyint,
    @POSPrice smallmoney,
    @Price smallmoney = null,
    @OldStartDate smalldatetime,
	-- new param placed at the end so it can be optional
    @InsertApplication varchar(30) = null,
    @ValidationCode int OUTPUT,
	@CancelAllSales int = null
AS

BEGIN
    SET NOCOUNT ON

    DECLARE @Error_No int, @Severity smallint
    SELECT @Error_No = 0
    
    DECLARE @PriceChgTypeId int
    SELECT @PriceChgTypeId = PriceChgTypeId
    FROM PriceChgType
    WHERE On_Sale = 0

	-- If no Price param was supplied, use the POSPrice value to place into the Price field (as for the US).
	SET @Price = ISNULL(@Price, @POSPrice)

	IF @User_ID IS NOT NULL
    IF NOT EXISTS (SELECT * FROM Item (rowlock) WHERE Item_Key = @Item_Key AND User_ID = @User_ID AND User_ID_Date = @User_ID_Date)
    BEGIN
        RAISERROR ('Item is not locked by the current user or the lock date-time do not match', 16, 1)
        RETURN
    END

    -- Validate the price change data before attempting the save.
    SET @ValidationCode = dbo.fn_ValidateRegularPriceChange(@Item_Key,@Store_No,@PriceChgTypeID,@StartDate,@Multiple,@POSPrice,@OldStartDate)

	IF @ValidationCode = 0 OR dbo.fn_IsWarningValidationCode(@ValidationCode) = 1
	BEGIN
		-- The validation was a success or warning.  Save the updates to the database.
		
		--20091105 - Dave Stacey VAT handling for UK upgrade
		--Set VAT to price if necessary
		IF @POSPrice IS NOT NULL
			IF ISNULL(@Price, 0) = ISNULL(@POSPrice, 0)
				IF dbo.fn_InstanceDataValue('UseVAT', @Store_No) = 1 
					SELECT @Price = ISNULL(@POSPrice, 0) / (ISNULL(TD.TaxPercent/100, 0) + 1) 
					FROM dbo.Store S (NOLOCK)
						LEFT JOIN dbo.TaxFlag TF (NOLOCK) ON TF.TaxJurisdictionID = S.TaxJurisdictionID
						LEFT JOIN dbo.TaxDefinition TD (NOLOCK) ON TD.TaxFlagKey = TF.TaxFlagKey
							AND TD.TaxJurisdictionID = TF.TaxJurisdictionID
					WHERE S.Store_No = @Store_No
						AND TF.TaxFlagValue = 1
						AND TF.TaxClassID = (SELECT TaxClassID FROM dbo.Item (NOLOCK) WHERE Item_Key = @Item_Key)

		DECLARE @PriceBatchDetailID int

		IF @OldStartDate IS NOT NULL
		BEGIN
			SELECT @PriceBatchDetailID = PriceBatchDetailID
			FROM PriceBatchDetail D
			WHERE Item_Key = @Item_Key AND Store_No = @Store_No
				AND PriceChgTypeID = @PriceChgTypeId
				AND PriceBatchHeaderID IS NULL
				AND @OldStartDate = StartDate
				AND Expired = 0
				AND AutoGenerated = 0
	    
			SELECT @error_no = @@ERROR

			IF @error_no <> 0
			BEGIN
				IF @@TRANCOUNT <> 0
					ROLLBACK TRAN
				SELECT @Severity = ISNULL((SELECT severity FROM master.dbo.sysmessages WHERE error = @error_no), 16)
				RAISERROR ('UpdatePriceBatchDetailReg failed with @@ERROR: %d', @Severity, 1, @error_no)
				RETURN
			END
		END

		BEGIN TRAN
		-- Expire any unbatched Regs for this Item/Store/StartDate - whether it's an insert or update
		UPDATE PriceBatchDetail
		SET	Expired = 1
		WHERE Item_Key = @Item_Key 
		AND Store_No = @Store_No
		AND StartDate = @StartDate
		AND PriceBatchHeaderID IS NULL
		
		SELECT @Error_No = @@ERROR
		
		IF (@Error_No = 0)
		BEGIN
			-- Main update/insert
			IF @PriceBatchDetailID IS NULL
			BEGIN
				INSERT INTO PriceBatchDetail (Item_Key, Store_No, PriceChgTypeID, StartDate, Multiple, Price, POSPrice,AutoGenerated, Expired, User_ID, User_ID_Date, InsertApplication, CancelAllSales)
				VALUES (@Item_Key, @Store_No, @PriceChgTypeId, @StartDate, @Multiple, @Price, @POSPrice,0 , 0, @User_ID, @User_ID_Date, @InsertApplication, @CancelAllSales)

				SELECT @Error_No = @@ERROR
		        
		        --*****************************************************************
		        -- TFS #6654 (V3.2) 
		        -- Old behavior was to expire auto-generated Reg prices.
		        -- New behavior is to let existing REG changes stay as long as the start date is not today.
		        --*****************************************************************
				-- TFS #8443 (v3.4.x)
				-- The fix for 6654 did a little too much here. We still want to be able to expire REG price changes
				-- when a new REG is loaded for an item that is currently on sale.
				-- Expire any unbatched auto-generated Regular prices for this Item/Store 
				-- as long as the existing StartDate is >= @StartDate and the existing start date is not today.
				IF (@Error_No = 0)
				BEGIN
					UPDATE PriceBatchDetail
					SET	Expired = 1
					WHERE Item_Key = @Item_Key 
					AND Store_No = @Store_No
					AND AutoGenerated = 1
					AND PriceBatchHeaderID IS NULL
					AND StartDate >= @StartDate 
					AND StartDate <> GetDate()
				END
		        
			END
			ELSE
			BEGIN
				UPDATE PriceBatchDetail
				SET StartDate = @StartDate,
					Multiple = @Multiple,
					Price = @Price,
					POSPrice = @POSPrice,
					AutoGenerated = 0
										
					-- TFS #1601 (V4.2)
					,Expired = 0

				WHERE PriceBatchDetailID = @PriceBatchDetailID
		        
				SELECT @Error_No = @@ERROR
			END

		END

		SET NOCOUNT OFF

		IF @error_no = 0
			COMMIT TRAN
		ELSE
		BEGIN
			IF @@TRANCOUNT <> 0
				ROLLBACK TRAN
			SELECT @Severity = ISNULL((SELECT severity FROM master.dbo.sysmessages WHERE error = @error_no), 16)
			RAISERROR ('UpdatePriceBatchDetailReg failed with @@ERROR: %d', @Severity, 1, @error_no)
		END
	END
END


GO
GRANT EXECUTE
    ON OBJECT::[dbo].[UpdatePriceBatchDetailReg] TO [IRMAClientRole]
    AS [dbo];


GO
GRANT EXECUTE
    ON OBJECT::[dbo].[UpdatePriceBatchDetailReg] TO [IRMASchedJobsRole]
    AS [dbo];


GO
GRANT EXECUTE
    ON OBJECT::[dbo].[UpdatePriceBatchDetailReg] TO [IRMAReportsRole]
    AS [dbo];


GO
GRANT EXECUTE
    ON OBJECT::[dbo].[UpdatePriceBatchDetailReg] TO [IRMASLIMRole]
    AS [dbo];

