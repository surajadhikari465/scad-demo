/*
Deployment script for IconTestStage2

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "IconTestStage2"
:setvar DefaultFilePrefix "IconTestStage2"
:setvar DefaultDataPath "E:\SQL_DATA\SQLSHARED2012D\"
:setvar DefaultLogPath "E:\SQL_LOGS\SQLSHARED2012D\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Dropping [dbo].[ScanCode].[ScanCode_scanCode]...';


GO
DROP INDEX [ScanCode_scanCode]
    ON [dbo].[ScanCode];


GO
PRINT N'Dropping DF_InsertDate...';


GO
ALTER TABLE [app].[EventQueue] DROP CONSTRAINT [DF_InsertDate];


GO
PRINT N'Dropping FK_EventQueue_EventType...';


GO
ALTER TABLE [app].[EventQueue] DROP CONSTRAINT [FK_EventQueue_EventType];


GO
PRINT N'Dropping [app].[UpdateItemListByTrait]...';


GO
DROP PROCEDURE [app].[UpdateItemListByTrait];


GO
PRINT N'Dropping [app].[Init.PopData.SetupOrganization]...';


GO
DROP PROCEDURE [app].[Init.PopData.SetupOrganization];


GO
PRINT N'Dropping [app].[Init.PopData.SetupParty]...';


GO
DROP PROCEDURE [app].[Init.PopData.SetupParty];


GO
PRINT N'Dropping [app].[ItemListByTraitType]...';


GO
DROP TYPE [app].[ItemListByTraitType];


GO
PRINT N'Creating [app].[ItemListByTraitType]...';


GO
CREATE TYPE [app].[ItemListByTraitType] AS TABLE (
    [itemID]     INT            NULL,
    [traitID]    INT            NULL,
    [traitDesc]  NVARCHAR (255) NULL,
    [traitValue] NVARCHAR (255) NULL);


GO
PRINT N'Creating [app].[EventQueueEntriesType]...';


GO
CREATE TYPE [app].[EventQueueEntriesType] AS TABLE (
    [EventMessage]     NVARCHAR (255) NULL,
    [EventReferenceId] INT            NULL);


GO
PRINT N'Creating [app].[RegionAbbrType]...';


GO
CREATE TYPE [app].[RegionAbbrType] AS TABLE (
    [RegionAbbr] CHAR (2) NULL);


GO
PRINT N'Creating [app].[TaxHierarchyClassUpdateType]...';


GO
CREATE TYPE [app].[TaxHierarchyClassUpdateType] AS TABLE (
    [HierarchyClassID]   NVARCHAR (7)   NULL,
    [HierarchyClassName] NVARCHAR (255) NULL);


GO
PRINT N'Creating [app].[UpdatedItemIDsType]...';


GO
CREATE TYPE [app].[UpdatedItemIDsType] AS TABLE (
    [itemID] INT NULL);


GO
PRINT N'Creating [app].[IRMAPush]...';


GO
CREATE TABLE [app].[IRMAPush] (
    [IRMAPushID]         INT            IDENTITY (1, 1) NOT NULL,
    [RegionCode]         VARCHAR (4)    NOT NULL,
    [BusinessUnit_ID]    INT            NOT NULL,
    [Identifier]         VARCHAR (13)   NOT NULL,
    [ChangeType]         VARCHAR (30)   NOT NULL,
    [InsertDate]         DATETIME       NOT NULL,
    [RetailSize]         DECIMAL (9, 4) NULL,
    [RetailPackageUom]   VARCHAR (5)    NULL,
    [TMDiscountEligible] BIT            NULL,
    [Case_Discount]      BIT            NULL,
    [AgeCode]            INT            NULL,
    [Recall_Flag]        BIT            NULL,
    [Restricted_Hours]   BIT            NULL,
    [Sold_By_Weight]     BIT            NULL,
    [ScaleForcedTare]    BIT            NULL,
    [Quantity_Required]  BIT            NULL,
    [Price_Required]     BIT            NULL,
    [QtyProhibit]        BIT            NULL,
    [VisualVerify]       BIT            NULL,
    [RestrictSale]       BIT            NULL,
    [Price]              MONEY          NULL,
    [RetailUom]          VARCHAR (5)    NULL,
    [Multiple]           INT            NULL,
    [SaleMultiple]       INT            NULL,
    [Sale_Price]         MONEY          NULL,
    [Sale_Start_Date]    SMALLDATETIME  NULL,
    [Sale_End_Date]      SMALLDATETIME  NULL,
    [InProcessBy]        VARCHAR (30)   NULL,
    [InUdmDate]          DATETIME2 (7)  NULL,
    [EsbReadyDate]       DATETIME2 (7)  NULL,
    [UdmFailedDate]      DATETIME2 (7)  NULL,
    [EsbReadyFailedDate] DATETIME2 (7)  NULL,
    CONSTRAINT [PK_IrmaPush_IrmaPushID] PRIMARY KEY CLUSTERED ([IRMAPushID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [UQ_IrmaPush_keys] UNIQUE NONCLUSTERED ([BusinessUnit_ID] ASC, [Identifier] ASC, [ChangeType] ASC, [InsertDate] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageAction]...';


GO
CREATE TABLE [app].[MessageAction] (
    [MessageActionId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageActionName] NVARCHAR (255) NOT NULL,
    CONSTRAINT [PK_MessageActionId] PRIMARY KEY CLUSTERED ([MessageActionId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageException]...';


GO
CREATE TABLE [app].[MessageException] (
    [MessageExceptionId] INT             IDENTITY (1, 1) NOT NULL,
    [MessageHistoryId]   INT             NOT NULL,
    [ResponseCode]       NVARCHAR (255)  NULL,
    [Severity]           NVARCHAR (255)  NULL,
    [Code]               NVARCHAR (255)  NULL,
    [Description]        NVARCHAR (4000) NULL,
    [AdditionalData]     NVARCHAR (255)  NULL,
    [InsertDate]         DATETIME2 (7)   NOT NULL,
    CONSTRAINT [PK_MessageExceptionId] PRIMARY KEY CLUSTERED ([MessageExceptionId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageHistory]...';


GO
CREATE TABLE [app].[MessageHistory] (
    [MessageHistoryId] INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]    INT            NOT NULL,
    [MessageStatusId]  INT            NOT NULL,
    [Note]             NVARCHAR (255) NULL,
    [Message]          XML            NOT NULL,
    [InsertDate]       DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageHistoryId] PRIMARY KEY CLUSTERED ([MessageHistoryId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueHierarchy]...';


GO
CREATE TABLE [app].[MessageQueueHierarchy] (
    [MessageQueueId]         INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]          INT            NOT NULL,
    [MessageStatusId]        INT            NOT NULL,
    [MessageHistoryId]       INT            NULL,
    [MessageActionId]        INT            NOT NULL,
    [HierarchyId]            INT            NOT NULL,
    [HierarchyName]          NVARCHAR (255) NOT NULL,
    [HierarchyLevelName]     NVARCHAR (255) NOT NULL,
    [ItemsAttached]          BIT            NOT NULL,
    [HierarchyClassId]       INT            NOT NULL,
    [HierarchyClassName]     NVARCHAR (255) NOT NULL,
    [HierarchyLevel]         INT            NOT NULL,
    [HierarchyParentClassId] INT            NULL,
    [InsertDate]             DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueueHierarchy] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueItemLocale]...';


GO
CREATE TABLE [app].[MessageQueueItemLocale] (
    [MessageQueueId]     INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]      INT            NOT NULL,
    [MessageStatusId]    INT            NOT NULL,
    [MessageHistoryId]   INT            NULL,
    [MessageActionId]    INT            NOT NULL,
    [IRMAPushID]         INT            NOT NULL,
    [RegionCode]         VARCHAR (4)    NOT NULL,
    [BusinessUnit_ID]    INT            NOT NULL,
    [ItemId]             INT            NOT NULL,
    [ItemTypeCode]       NVARCHAR (3)   NOT NULL,
    [ItemTypeDesc]       NVARCHAR (255) NOT NULL,
    [LocaleId]           INT            NOT NULL,
    [LocaleName]         VARCHAR (255)  NOT NULL,
    [ScanCodeId]         INT            NOT NULL,
    [ScanCode]           VARCHAR (13)   NOT NULL,
    [ScanCodeTypeId]     INT            NOT NULL,
    [ScanCodeTypeDesc]   NVARCHAR (255) NOT NULL,
    [ChangeType]         VARCHAR (32)   NOT NULL,
    [LockedForSale]      BIT            NOT NULL,
    [Recall]             BIT            NOT NULL,
    [RetailSize]         DECIMAL (9, 4) NULL,
    [RetailPackageUom]   VARCHAR (5)    NULL,
    [TMDiscountEligible] BIT            NULL,
    [Case_Discount]      BIT            NULL,
    [AgeCode]            INT            NULL,
    [Restricted_Hours]   BIT            NULL,
    [Sold_By_Weight]     BIT            NULL,
    [ScaleForcedTare]    BIT            NULL,
    [Quantity_Required]  BIT            NULL,
    [Price_Required]     BIT            NULL,
    [QtyProhibit]        BIT            NULL,
    [VisualVerify]       BIT            NULL,
    [InsertDate]         DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueueItemLocale] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueLocale]...';


GO
CREATE TABLE [app].[MessageQueueLocale] (
    [MessageQueueId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]    INT            NOT NULL,
    [MessageStatusId]  INT            NOT NULL,
    [MessageHistoryId] INT            NULL,
    [LocaleId]         INT            NOT NULL,
    [OwnerOrgPartyId]  INT            NOT NULL,
    [LocaleName]       NVARCHAR (255) NOT NULL,
    [LocaleOpenDate]   DATE           NULL,
    [LocaleCloseDate]  DATE           NULL,
    [LocaleTypeId]     INT            NOT NULL,
    [ParentLocaleId]   INT            NULL,
    [BusinessUnitId]   NVARCHAR (255) NOT NULL,
    [InsertDate]       DATETIME2 (7)  NOT NULL,
    [CountryCode]      NVARCHAR (3)   NULL,
    [TerritoryCode]    NVARCHAR (3)   NULL,
    [CityCode]         INT            NULL,
    [PostalCode]       INT            NULL,
    [Latitude]         NVARCHAR (255) NULL,
    [Longitude]        NVARCHAR (255) NULL,
    [AddressLine1]     NVARCHAR (255) NULL,
    [AddressLine2]     NVARCHAR (255) NULL,
    [AddressLine3]     NVARCHAR (255) NULL,
    [TimezoneCode]     INT            NULL,
    CONSTRAINT [PK_app.MessageQueueLocale] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueuePrice]...';


GO
CREATE TABLE [app].[MessageQueuePrice] (
    [MessageQueueId]        INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]         INT            NOT NULL,
    [MessageStatusId]       INT            NOT NULL,
    [MessageHistoryId]      INT            NULL,
    [IRMAPushID]            INT            NOT NULL,
    [RegionCode]            NVARCHAR (4)   NOT NULL,
    [BusinessUnit_ID]       INT            NOT NULL,
    [ItemId]                INT            NOT NULL,
    [ItemTypeCode]          NVARCHAR (3)   NOT NULL,
    [ItemTypeDesc]          NVARCHAR (255) NOT NULL,
    [LocaleId]              INT            NOT NULL,
    [LocaleName]            NVARCHAR (255) NOT NULL,
    [ScanCodeId]            INT            NOT NULL,
    [ScanCode]              NVARCHAR (13)  NOT NULL,
    [ScanCodeTypeId]        INT            NOT NULL,
    [ScanCodeTypeDesc]      NVARCHAR (255) NOT NULL,
    [ChangeType]            NVARCHAR (32)  NOT NULL,
    [UomCode]               NVARCHAR (3)   NOT NULL,
    [UomName]               NVARCHAR (100) NULL,
    [CurrencyCode]          NVARCHAR (3)   NOT NULL,
    [Price]                 MONEY          NULL,
    [Multiple]              INT            NULL,
    [SalePrice]             MONEY          NULL,
    [SaleMultiple]          INT            NULL,
    [SaleStartDate]         DATETIME2 (7)  NULL,
    [SaleEndDate]           DATETIME2 (7)  NULL,
    [PreviousSalePrice]     MONEY          NULL,
    [PreviousSaleMultiple]  INT            NULL,
    [PreviousSaleStartDate] DATETIME2 (7)  NULL,
    [PreviousSaleEndDate]   DATETIME2 (7)  NULL,
    [InsertDate]            DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueuePrice] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueProduct]...';


GO
CREATE TABLE [app].[MessageQueueProduct] (
    [MessageQueueId]         INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]          INT            NOT NULL,
    [MessageStatusId]        INT            NOT NULL,
    [MessageHistoryId]       INT            NULL,
    [ItemId]                 INT            NOT NULL,
    [LocaleId]               INT            NOT NULL,
    [ItemTypeCode]           NVARCHAR (3)   NOT NULL,
    [ItemTypeDesc]           NVARCHAR (255) NOT NULL,
    [ScanCodeId]             INT            NOT NULL,
    [ScanCode]               NVARCHAR (13)  NOT NULL,
    [ScanCodeTypeId]         INT            NOT NULL,
    [ScanCodeTypeDesc]       NVARCHAR (255) NOT NULL,
    [ProductDescription]     NVARCHAR (255) NOT NULL,
    [PosDescription]         NVARCHAR (255) NOT NULL,
    [PackageUnit]            NVARCHAR (255) NOT NULL,
    [FoodStampEligible]      NVARCHAR (255) NOT NULL,
    [PosScaleTare]           NVARCHAR (255) NOT NULL,
    [DepartmentSale]         NVARCHAR (255) NOT NULL,
    [BrandId]                INT            NOT NULL,
    [BrandName]              NVARCHAR (255) NOT NULL,
    [BrandLevel]             INT            NOT NULL,
    [BrandParentId]          INT            NULL,
    [BrowsingClassId]        INT            NULL,
    [BrowsingClassName]      NVARCHAR (255) NULL,
    [BrowsingLevel]          INT            NULL,
    [BrowsingParentId]       INT            NULL,
    [MerchandisingClassId]   INT            NOT NULL,
    [MerchandisingClassName] NVARCHAR (255) NOT NULL,
    [MerchandisingLevel]     INT            NOT NULL,
    [MerchandisingParentId]  INT            NULL,
    [TaxClassId]             INT            NOT NULL,
    [TaxClassName]           NVARCHAR (255) NOT NULL,
    [TaxLevel]               INT            NOT NULL,
    [TaxParentId]            INT            NULL,
    [FinancialClassId]       INT            NOT NULL,
    [FinancialClassName]     NVARCHAR (255) NOT NULL,
    [FinancialLevel]         INT            NOT NULL,
    [FinancialParentId]      INT            NULL,
    [InsertDate]             DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueueProduct] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageResponse]...';


GO
CREATE TABLE [app].[MessageResponse] (
    [MessageResponseId] INT           IDENTITY (1, 1) NOT NULL,
    [MessageHistoryId]  INT           NOT NULL,
    [ResponseText]      XML           NOT NULL,
    [Success]           BIT           NOT NULL,
    [InsertDate]        DATETIME2 (7) NOT NULL,
    CONSTRAINT [PK_MessageResponse] PRIMARY KEY CLUSTERED ([MessageResponseId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageStatus]...';


GO
CREATE TABLE [app].[MessageStatus] (
    [MessageStatusId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageStatusName] NVARCHAR (255) NOT NULL,
    CONSTRAINT [PK_MessageStatusId] PRIMARY KEY CLUSTERED ([MessageStatusId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageType]...';


GO
CREATE TABLE [app].[MessageType] (
    [MessageTypeId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeName] NVARCHAR (255) NOT NULL,
    CONSTRAINT [PK_MessageTypeId] PRIMARY KEY CLUSTERED ([MessageTypeId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [dbo].[ItemHierarchyClass].[ItemHierarchyClass_itemID]...';


GO
CREATE NONCLUSTERED INDEX [ItemHierarchyClass_itemID]
    ON [dbo].[ItemHierarchyClass]([itemID] ASC)
    INCLUDE([hierarchyClassID]) WITH (FILLFACTOR = 80);


GO
PRINT N'Creating DF_IRMAPush_InsertDate...';


GO
ALTER TABLE [app].[IRMAPush]
    ADD CONSTRAINT [DF_IRMAPush_InsertDate] DEFAULT (getdate()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageException_InsertDate...';


GO
ALTER TABLE [app].[MessageException]
    ADD CONSTRAINT [DF_MessageException_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageHistory_InsertDate...';


GO
ALTER TABLE [app].[MessageHistory]
    ADD CONSTRAINT [DF_MessageHistory_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueueHierarchy_InsertDate...';


GO
ALTER TABLE [app].[MessageQueueHierarchy]
    ADD CONSTRAINT [DF_MessageQueueHierarchy_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueueItemLocale_LockedForSale...';


GO
ALTER TABLE [app].[MessageQueueItemLocale]
    ADD CONSTRAINT [DF_MessageQueueItemLocale_LockedForSale] DEFAULT ((0)) FOR [LockedForSale];


GO
PRINT N'Creating DF_MessageQueueItemLocale_Recall...';


GO
ALTER TABLE [app].[MessageQueueItemLocale]
    ADD CONSTRAINT [DF_MessageQueueItemLocale_Recall] DEFAULT ((0)) FOR [Recall];


GO
PRINT N'Creating DF_MessageQueueItemLocale_InsertDate...';


GO
ALTER TABLE [app].[MessageQueueItemLocale]
    ADD CONSTRAINT [DF_MessageQueueItemLocale_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueuePrice_InsertDate...';


GO
ALTER TABLE [app].[MessageQueuePrice]
    ADD CONSTRAINT [DF_MessageQueuePrice_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueueProduct_InsertDate...';


GO
ALTER TABLE [app].[MessageQueueProduct]
    ADD CONSTRAINT [DF_MessageQueueProduct_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating FK_MessageException_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageException] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageException_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageHistory_MessageStatus...';


GO
ALTER TABLE [app].[MessageHistory] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageHistory_MessageStatus] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageHistory_MessageType...';


GO
ALTER TABLE [app].[MessageHistory] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageHistory_MessageType] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageActionId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageActionId] FOREIGN KEY ([MessageActionId]) REFERENCES [app].[MessageAction] ([MessageActionId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageTypeId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageTypeId] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageTypeId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageTypeId] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_IRMAPushID...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_IRMAPushID] FOREIGN KEY ([IRMAPushID]) REFERENCES [app].[IRMAPush] ([IRMAPushID]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageActionId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageActionId] FOREIGN KEY ([MessageActionId]) REFERENCES [app].[MessageAction] ([MessageActionId]);


GO
PRINT N'Creating FK_app.MessageQueueLocale_MessageType...';


GO
ALTER TABLE [app].[MessageQueueLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_app.MessageQueueLocale_MessageType] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_app.MessageQueueLocale_MessageStatus...';


GO
ALTER TABLE [app].[MessageQueueLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_app.MessageQueueLocale_MessageStatus] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_app.MessageQueueLocale_MessageHistory...';


GO
ALTER TABLE [app].[MessageQueueLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_app.MessageQueueLocale_MessageHistory] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueuePrice_MessageTypeID...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_MessageTypeID] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueuePrice_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueuePrice_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueuePrice_IRMAPushID...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_IRMAPushID] FOREIGN KEY ([IRMAPushID]) REFERENCES [app].[IRMAPush] ([IRMAPushID]);


GO
PRINT N'Creating FK_MessageQueuePrice_UomCode...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_UomCode] FOREIGN KEY ([UomCode]) REFERENCES [dbo].[UOM] ([uomCode]);


GO
PRINT N'Creating FK_MessageQueuePrice_CurrencyCode...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_CurrencyCode] FOREIGN KEY ([CurrencyCode]) REFERENCES [dbo].[CurrencyType] ([currencyTypeCode]);


GO
PRINT N'Creating FK_MessageQueueProduct_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueueProduct] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueProduct_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueueProduct_MessageTypeId...';


GO
ALTER TABLE [app].[MessageQueueProduct] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueProduct_MessageTypeId] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueProduct_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueueProduct] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueProduct_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Altering [app].[vItemBase]...';


GO
/*
Index Help:
Missing Index Details - sqlshared2-dev\sqlshared2012d.iCon (WFM\Tom.Lux (58))
The Query Processor estimates that implementing the following index could improve the query cost by 75.1693%.

USE [iCon]
GO
CREATE NONCLUSTERED INDEX [???]
ON [dbo].[ItemTrait] ([itemID])
INCLUDE ([traitID],[traitValue])
GO
*/


ALTER VIEW [app].[vItemBase]
	AS
SELECT
	[ItemID]				= i.itemID
	,[ScanCode]				= scn.scancode
	,[Product Description]	= lng.traitvalue
	,[POS Description]		= sht.traitvalue
	,[Package Unit]			= pu.traitvalue
	,[Food Stamp Eligible]	= 'not yet defined'
	,[Tare]					= 'not yet defined'
	,[Brand]				= hc.hierarchyclassname
FROM
	item i
JOIN scancode scn
	ON i.itemid = scn.itemid
JOIN scancodetype tscn
	ON scn.scancodetypeid = tscn.scancodetypeid
	AND tscn.scancodetypedesc = 'UPC'
JOIN itemtrait lng
	ON i.itemid = lng.itemid
JOIN trait tlng
	ON lng.traitID = tlng.traitID
	AND tlng.traitdesc = 'Product Description'
JOIN itemtrait sht
	ON i.itemid = sht.itemid
JOIN trait tsht
	ON sht.traitID = tsht.traitID
	AND tsht.traitdesc = 'POS Description'
JOIN itemtrait pu
	ON i.itemid = pu.itemid
JOIN trait tpu
	ON pu.traitID = tpu.traitID
	AND tpu.traitdesc = 'Package Unit'
JOIN itemhierarchyclass ihc
	ON i.itemid = ihc.itemid
JOIN hierarchyclass hc
	ON ihc.hierarchyclassid = hc.hierarchyclassid
JOIN hierarchy h
	ON hc.hierarchyid = h.hierarchyid
	AND h.hierarchyname = 'Brand'
GO
PRINT N'Altering [app].[vItemImport]...';


GO
ALTER VIEW [app].[vItemImport]
	AS
SELECT
	[ItemID]				= i.itemID
	,[ScanCode]				= scn.scanCode
	,[Product Description]	= lng.traitvalue
	,[POS Description]		= sht.traitvalue
	,[Package Unit]			= pu.traitvalue
	,[Food Stamp Eligible]	= '?'
	,[Tare]					= 'NAN'
FROM
	item i
JOIN scancode scn
	ON i.itemid = scn.itemid
JOIN itemtrait lng
	ON i.itemid = lng.itemid
JOIN trait tlng
	ON lng.traitID = tlng.traitID
	AND tlng.traitdesc = 'Product Description'
JOIN itemtrait sht
	ON i.itemid = sht.itemid
JOIN trait tsht
	ON sht.traitID = tsht.traitID
	AND tsht.traitdesc = 'POS Description'
JOIN itemtrait pu
	ON i.itemid = pu.itemid
JOIN trait tpu
	ON pu.traitID = tpu.traitID
	AND tpu.traitdesc = 'Package Unit'
GO
PRINT N'Altering [app].[vItemsAndTraits]...';


GO
ALTER VIEW [app].[vItemsAndTraits]
AS
/*
	This is a simple view to get the scancode and trait details (code, name, value) for all items.
*/
select
	i.itemID
	,sc.scanCode
	,t.traitDesc
	,it.traitValue
from item i
join ScanCode sc
on i.itemID = sc.itemID
join ItemTrait it
on i.itemID = it.itemID
join Trait t
on it.traitID = t.traitID
GO
PRINT N'Creating [app].[vValidatedItems]...';


GO
/*
Title: View of Validated Items with POS Attributes to be sent back to IRMA

Description: This view shows only validated scancodes with the all traits.
			 This view will not show non-validated scancodes and will not show
			 validated scancodes that do not have the following traits defined:
			 ValidationDate, Product Description, POS Description, Package Unit,
			 Food Stamp Eligible, POS Scale Tare and the hierarchies Brand and Tax.

Change History: TFS		Initials	Description		Date
				2625	BJL			View Creation	2014-04-11
*/
CREATE VIEW [app].[vValidatedItems]
	AS
SELECT
	 [ItemID]				= vi.[itemID]
	,[ValidationDate]		= vi.[traitValue]
	,[ScanCode]				= scn.[scancode]
	,[ScanCodeType]			= tscn.[scancodetypedesc]
	,[ProductDescription]	= lng.[traitValue]
	,[POSDescription]		= sht.[traitValue]
	,[PackageUnit]			= pu.[traitValue]
	,[FoodStampEligible]	= fs.[traitValue]
	,[Tare]					= pst.[traitValue]
	,[BrandId]				= hcb.[hierarchyclassID]
	,[Brand]				= hcb.[hierarchyclassname]
	,[Tax]					= hct.[hierarchyclassname]

FROM

-- Validation Date
(SELECT i.[itemId], vd.[traitValue]
FROM [Item] i				
JOIN [ItemTrait] vd		ON i.[itemID] = vd.[itemid]
JOIN [Trait] tvd			ON vd.[traitID] = tvd.[traitID]
							AND tvd.[traitdesc] = 'Validation Date') as vi

-- ScanCode for UPC
JOIN [scancode] scn		ON vi.[itemid] = scn.[itemid]
JOIN [scancodetype] tscn	ON scn.[scancodetypeid] = tscn.[scancodetypeid]

-- Product Description
JOIN [itemtrait] lng		ON vi.[itemid] = lng.[itemid]
JOIN [trait] tlng			ON lng.[traitID] = tlng.[traitID]
						AND tlng.[traitDesc] = 'Product Description'

-- POS Description
JOIN [ItemTrait] sht		ON vi.[itemid] = sht.[itemid]
JOIN [trait] tsht			ON sht.[traitID] = tsht.[traitID]
						AND tsht.[traitdesc] = 'POS Description'

-- Package Unit
JOIN [itemtrait] pu		ON vi.[itemid] = pu.[itemid]
JOIN [trait] tpu			ON pu.[traitID] = tpu.[traitID]
						AND tpu.[traitdesc] = 'Package Unit'

-- Food Stamp Eligible
JOIN [itemtrait] fs		ON vi.[itemid] = fs.[itemid]
JOIN [trait] tfs			ON fs.[traitID] = tfs.[traitID]
						AND tfs.[traitdesc] = 'Food Stamp Eligible'

-- POS Scale Tare
JOIN [itemtrait] pst		ON vi.[itemid] = pst.[itemid]
JOIN [trait] tpst			ON pst.[traitID] = tpst.[traitID]
						AND tpst.[traitdesc] = 'POS Scale Tare'

-- Brand
JOIN [itemhierarchyclass] ihcb	ON vi.[itemid] = ihcb.[itemid]
JOIN [hierarchyclass] hcb			ON ihcb.[hierarchyclassid] = hcb.[hierarchyclassid]
JOIN [hierarchy] hb				ON hcb.[hierarchyid] = hb.[hierarchyid]
								AND hb.[hierarchyname] = 'Brand'

-- Tax
JOIN [itemhierarchyclass] ihct	ON vi.[itemid] = ihct.[itemid]
JOIN [hierarchyclass] hct			ON ihct.[hierarchyclassid] = hct.[hierarchyclassid]
JOIN [hierarchy] ht				ON hct.[hierarchyid] = ht.[hierarchyid]
								AND ht.[hierarchyname] = 'Tax'
GO
PRINT N'Altering [app].[pivot_query]...';


GO
ALTER procedure [app].pivot_query
   (
   @query         varchar(MAX),
   @row_fields    varchar(8000),
   @col_field     varchar(1000),
   @agg_func_list varchar(8000),
   @dest_table    varchar(1000) = null,
   @show_query    char(1) = null
   )
as
--**************************************************************************
-- Procedure: pivot_query()
--    Author: Ron Savage
--      Date: 05/20/2007
--
-- Description:
-- This procedure makes a pivot table out of the input arguments using the
-- spiffy new PIVOT feature in SQL Server 2005.  Only up to 147 columns
-- of pivoted data though .. more crashes it.
--
-- Syntax:
-- pivot_query '<query>', '<field list for each row>', '<pivot column>', '<aggregate expression list>', '[<results table>]', '[<show query>]'
--
--    '<query>'                     - Query defining the data to pivot
--    '<field list for each row>'   - List of fields to show for each row of data, to the left of the pivot (comma delimited)
--    '<pivot column>'              - The column that contains the column headers of the pivoted data
--    '<aggregate expression list>' - A list of function(field) expressions to calculate for the pivot.
--    '[<results table>]'           - An optional table to create for the results of the pivot, it will be dropped and re-created
--    '[<show query>]'              - An optional value to have the proc show the pivot query for debugging. Any char value makes it print
--
-- Change History:
-- Date        Init. Description
-- 05/12/2014  RS    Removed ##log_table to avoid multi-process contention and fixed a bug with handling
--                   new data types.
-- 10/09/2009  RS    Updated the internal temp table to be named '##tmp_' + @PROCID + @SPID so each
--                   server process will get it's own temp table - multiple threads each get the same PROCID.
-- 10/08/2007  RS    Fixed sum() and count() cases for sql_variants.
-- 10/07/2007  RS    Altered to use the sql_variant type field in the inner temp tables to allow
--                   multiple aggregate fields to be different types, and to convert the sql_variant
--                   back to the original type on output.
-- 09/14/2007  RS    Increased parsing variable sizes to handle longer field name combinations.
-- 08/02/2007  RS    Copied from pivot_table and modified for passing in a query.
-- **************************************************************************
begin
   set nocount on;

   if ( @show_query is not null ) print char(13) + 'Starting ...';

   --**************************************************************************
   -- Declare some variables
   --**************************************************************************
   declare @pivot_sql  varchar(MAX);
   declare @sql        varchar(MAX);
   declare @piv_value  varchar(300);
   declare @piv_type   varchar(300);

   set @pivot_sql = '';
   set @sql       = '';

   --**************************************************************************
   -- Declare variables for parsing the agg expression list
   --**************************************************************************
   declare @sub_start  integer;
   declare @sub_len    integer;
   declare @del_loc    integer;
   declare @agg_exp    varchar(1000);
   declare @agg_func   varchar(300);
   declare @agg_lbl    varchar(300);
   declare @agg_tag    varchar(300);
   declare @agg_field  varchar(1000);
   declare @agg_fld    varchar(300);
   declare @tmp_table  varchar(300);
   declare @fld_index  integer;
   declare @tname      varchar(300);
   declare @tbl_select varchar(MAX);

   set @sub_start = 1;
   set @sub_len   = 0;
   set @fld_index = 1;

   --**************************************************************************
   -- Declare a process id specific temp table
   --**************************************************************************
   set @tmp_table = '##tmp_' + cast(@@procid as varchar(15))+ cast(@@spid as varchar(15));

   --**************************************************************************
   -- Drop if the temp table exists
   --**************************************************************************
--    if exists (select * from dbo.sysobjects where  name = @tmp_table)
   BEGIN TRY
      exec('drop table ' + @tmp_table);
   END TRY
   BEGIN CATCH
--       print 'Woo! Caught one!';
   END CATCH

   --**************************************************************************
   -- Loop through each aggregate expression and insert the results into
   -- the temp table with a category label to pivot on when done
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'Looping and parsing [' + @agg_func_list + '] ...';

   while ( @sub_start < len(@agg_func_list) )
      begin
      set @del_loc   = charindex(',', @agg_func_list, @sub_start);

      if ( @del_loc > 0 )
         set @sub_len   = @del_loc - @sub_start;
      else
         set @sub_len   = len(@agg_func_list) - @sub_start + 1;

      --**************************************************************************
      -- Parse the expression, field and function and label
      --**************************************************************************
      set @agg_exp  = ltrim(rtrim(substring(@agg_func_list, @sub_start, @sub_len)));
      set @agg_fld  = ltrim(rtrim(substring(@agg_exp, charindex('(',@agg_exp) + 1, charindex(')',@agg_exp) - charindex('(',@agg_exp) - 1)));
      set @agg_func = ltrim(rtrim(substring(@agg_exp, 1, charindex('(',@agg_exp) - 1)));
      set @agg_lbl  = ltrim(rtrim(reverse(substring(reverse(@agg_exp), 1, charindex(' ',reverse(@agg_exp))))));

      if ( @agg_fld = '*' ) set @agg_fld = '1';

      set @agg_tag = case
                        when ( @fld_index = 1 and @agg_lbl = '' ) then 'cast(' + @col_field + ' as varchar(100))'
                        when ( @fld_index > 1 and @agg_lbl = '' ) then 'cast(' + @col_field + ' as varchar(100)) + ''_' + @agg_func + '_' + @agg_fld + ''''
                        else 'cast(' + @col_field + ' as varchar(100)) + ''_' + @agg_lbl + ''''
                     end

      if ( @show_query is not null ) print char(13) + 'Processing: [' + @agg_exp + '] into [' + @agg_func + '] [' + @agg_fld + '] ...';

      --**************************************************************************
      -- If it's the first first expression, define a select - into SQL
      --**************************************************************************
      if ( @sub_start = 1 )
         set @sql = 'select ' + @row_fields + ', ' +
                                @col_field + ' as col_field, ' +
                                @agg_tag + ' as cat, ' +
                                cast(@fld_index as varchar(3)) + ' as fld_num, ' +
                                'max(cast(' + char(13) +
                                'case cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10))' + char(13) +
                                '   when ''decimal''  then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''numeric''  then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''char''     then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nchar''    then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''varchar''  then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nvarchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   else                   cast(isnull(sql_variant_property(' + @agg_fld + ', ''BaseType''),''varchar(100)'') as varchar(20))' + char(13) +
                                'end as varchar(100))) as fld_type,' + char(13) +
                                'cast(' + @agg_func + '(' + @agg_fld + ') as sql_variant) as value ' + char(13) + 'into ' + @tmp_table + char(13) +
                                ' from (' + @query + ') as qry ' + char(13) +
                                ' group by ' + @row_fields + ', ' + @col_field  +
                                ',' + @agg_tag;
      else
      --**************************************************************************
      -- Otherwise, define an insert-into-select SQL
      --**************************************************************************
         set @sql = 'insert into ' + @tmp_table + ' select ' + @row_fields + ', ' +
                                @col_field + ' as col_field, '+
                                @agg_tag + 'as cat, ' +
                                cast(@fld_index as varchar(3)) + ' as fld_num, ' +
                                'max(cast(' + char(13) +
                                'case cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10))' + char(13) +
                                '   when ''decimal'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''numeric'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''char'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''varchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nvarchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   else cast(isnull(sql_variant_property(' + @agg_fld + ', ''BaseType''),''varchar(100)'') as varchar(20))' + char(13) +
                                'end as varchar(100))) as fld_type,' + char(13) +
                                'cast(' + @agg_func + '(' + @agg_fld + ') as sql_variant) as value ' + char(13) +
                                ' from (' + @query + ') as qry ' + char(13) +
                                ' group by ' + @row_fields + ', ' + @col_field  +
                                ',' + @agg_tag;

      set @sub_start = @sub_start + @sub_len + 1;
      set @fld_index = @fld_index + 1;

      exec(@sql);
      end

   --**************************************************************************
   -- Update the input variables to the new temp table and fields
   --**************************************************************************
   set @tname        = @tmp_table;
   set @col_field    = 'cat';
   set @agg_field    = 'value';

   if ( lower(@agg_func) = 'count' ) set @agg_func = 'sum';

   if ( @show_query is not null ) print char(13) + 'Changed table and fields to refer to the temp:  [' + @tname + '] [' + @col_field + '] [' + @agg_field + '] ...';

   --**************************************************************************
   -- Start building the PIVOT SQL
   --**************************************************************************
   set @pivot_sql = @pivot_sql +  'select' + char(13);
   set @pivot_sql = @pivot_sql +  '   pvt.*' + char(13);

   --**************************************************************************
   -- Put all the input arguments in thier proper places in the query
   --**************************************************************************
   set @pivot_sql = @pivot_sql +  'from' + char(13);
   set @pivot_sql = @pivot_sql +  '   (select ' + @row_fields + ', ' + @col_field + ', isnull(' + @agg_field + ',0) as '+ @agg_field + ' from ' + @tname + ') as c' + char(13);
   set @pivot_sql = @pivot_sql +  '       PIVOT' + char(13);
   set @pivot_sql = @pivot_sql +  '          (' + char(13);
--    set @pivot_sql = @pivot_sql +  '          ' + @agg_func + '(' + @agg_field + ')' + char(13);
   set @pivot_sql = @pivot_sql +  '          max(' + @agg_field + ')' + char(13);
   set @pivot_sql = @pivot_sql +  '          for ' + @col_field + ' in' + char(13);
   set @pivot_sql = @pivot_sql +  '             ( ';

   --**************************************************************************
   -- Get all the unique values of the Pivot column in the data table,
   -- these will become the pivoted columns.  For some reason, the PIVOT
   -- chokes if there are more than 147 result columns ... determined
   -- experimentally, so your mileage may vary.
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'Creating the #pivot_values table ...';
   create table #pivot_values ( piv_order  integer, fld_type varchar(100), piv_fldsort   varchar(100), piv_fld   varchar(100) );

   set @sql ='insert into #pivot_values select distinct top 147 fld_num, fld_type, col_field, ' + @col_field  + ' from ' + @tname + ' order by col_field, fld_num';

   exec(@sql);

   --**************************************************************************
   -- Loop through the values and add them to the PIVOT query SQL
   --**************************************************************************
   declare @piv_value_count integer;
   set @piv_value_count = 0;
   set @tbl_select = 'select ' + @row_fields + ',';

   declare piv_cursor cursor for
      select piv_fld, fld_type from #pivot_values order by piv_fldsort, piv_order;

   open piv_cursor;
   fetch next from piv_cursor into @piv_value,@piv_type;

   while @@FETCH_STATUS = 0
   begin
      set @pivot_sql  = @pivot_sql +  '[' + rtrim(isnull(@piv_value,'null')) + ']';
      set @tbl_select = @tbl_select + 'cast([' + rtrim(isnull(@piv_value,'null')) + '] as ' + rtrim(isnull(@piv_type,'null')) + ') as [' + rtrim(isnull(@piv_value,'null')) + ']';

      fetch next from piv_cursor into @piv_value,@piv_type;

      if @@FETCH_STATUS = 0
      begin
         set @pivot_sql  = @pivot_sql  +  ', ';
         set @tbl_select = @tbl_select +  ', ' + char(13);
      end

      set @piv_value_count = @piv_value_count + 1;
   end
   close piv_cursor;

   --**************************************************************************
   -- Finish off the PIVOT SQL
   --**************************************************************************
   set @pivot_sql = @pivot_sql +  ' )' + char(13);
   set @pivot_sql = @pivot_sql +  '          ) as pvt' + char(13);

   --**************************************************************************
   -- If we have a destination table, add the "into" statements
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'checking for destination table option ...';
   if ( @dest_table is not null )
      begin
         if ( @show_query is not null ) print char(13) + 'Dropping the dest table [' + @dest_table + '] if it exists ...';

         set @sql ='drop table ' + @dest_table;

         BEGIN TRY
            exec(@sql);
         END TRY
         BEGIN CATCH
         END CATCH

         set @pivot_sql = @tbl_select + ' into ' + @dest_table + ' from (' + @pivot_sql + ') as piv ' + char(13);
      end
   else
      set @pivot_sql = @tbl_select + ' from (' + @pivot_sql + ') as piv ' + char(13);

   if ( @show_query is not null ) print char(13) + 'adding order by clause ...';
   set @pivot_sql = @pivot_sql +  'order by' + char(13);
   set @pivot_sql = @pivot_sql +  '   ' + @row_fields + char(13);

   --**************************************************************************
   -- Run the PIVOT SQL
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'Running the Pivot SQL ...' + char(13) + @pivot_sql;
   if ( @piv_value_count > 0 )
      exec(@pivot_sql);
   else
      select 'There was no data to pivot.';

   BEGIN TRY
      exec('drop table ' + @tmp_table);
   END TRY
   BEGIN CATCH
   END CATCH
   return;
end
GO
PRINT N'Altering [app].[UpdateItemHierarchyClass]...';


GO
ALTER PROCEDURE [app].[UpdateItemHierarchyClass]
	/*
		NOTE: The list we are getting can have item-hier-class entries for many items and any/all hierarchies
		for those items (brand, browsing, merch, tax, etc.).
	*/
	@itemList [app].ItemListByHierarchyClassType READONLY
AS

	declare @taskName varchar(32)
	select @taskName = 'iCon.UpdateItemHierarchyClass'

	/*
		For item-hierarchy-class updates, we do the following:
		1) Delete any existing entry for the target item and parent hierarchy.
		2) Add/Insert item-hier-class entry.
	*/

	declare
		@removeItemHierClassList ItemListByHierarchyClassType,
		@expectedRemoveCount int, 
		@actualRemoveCount int,
		@localeID int

	set @localeID = 1;

	/*
		Identify existing hier-class entries for all items that need to be removed.
	*/

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Identifying existing item-hier-class entries to be removed...';
	insert into @removeItemHierClassList
		select
			sc.itemID,
			oldIHC.hierarchyClassID,
			localeID = 1
		from @itemList il  -- We use the passed list of item-hier-class entries to identify existing entries that we need to delete before we can add the new entry.
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.itemID = sc.itemID
		join ItemHierarchyClass oldIHC (nolock) -- Get hier class entries for each item.
			on sc.itemID = oldIHC.itemID
		join HierarchyClass currentHC (nolock) -- We need parent hier for the hier class, so we have to go through the hier class table to get hier ID.
			on oldIHC.hierarchyClassID = currentHC.hierarchyClassID
		join Hierarchy currentH (nolock) -- This gives us all hiers for hier classes linked to each item (brand, browsing, merch, etc.).
			on currentHC.hierarchyID = currentH.hierarchyID
		join HierarchyClass newHC (nolock) -- We need to lookup the new hier class we are assigning and match it to the same hier for any hier class currently linked to the item.
			on il.hierarchyClassID = newHC.hierarchyClassID
		join Hierarchy newH (nolock) -- This gives us the target parent hier for the hier class being assigned so we can remove existing entries before adding the new assignment entry.
			on newH.hierarchyID = newHC.hierarchyID
		where
			currentH.hierarchyID = newH.hierarchyID -- This links the hier, like "Brand", we are assigning to any existing hier entry for the item so we can remove it.

	select @expectedRemoveCount = @@rowcount

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Removing existing item-hier-class entries...';
	-- Remove existing item-hier-class entries.
	delete ItemHierarchyClass
	from ItemHierarchyClass ihc
	join @removeItemHierClassList del
		on ihc.itemID = del.itemID
		and ihc.hierarchyClassID = del.hierarchyClassID
		and isnull(ihc.localeID, 1) = isnull(del.localeID, 1)

	-- Determine rows affected to compare to what we thought should have been removed.
	select @actualRemoveCount = @@rowcount

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Verifying expected and actual item-hier-class rows removed...';
	if @actualRemoveCount <> @expectedRemoveCount
	begin
		DECLARE @ErrorMessage NVARCHAR(4000);
		select @ErrorMessage = 'The number of expected ItemHierarchyClass entries identified for removal [' + cast(@expectedRemoveCount as varchar) + ']'
		+ ' did not match the number affected rows from the DELETE attempt [' + cast(@actualRemoveCount as varchar) + ']'
		RAISERROR (
			@ErrorMessage -- Message text.
			,11 -- Severity.
			,0 -- State.
		)

	end

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding new item-hier-class entries...';
	-- Add new item-hier-class entries.
	insert into ItemHierarchyClass
		select * from @itemList

	-- Return item IDs where the item's hierarchy class has changed.
	declare @updatedItems table(
		itemID int,
		originalHierarchyClassID int,
		newHierarchyClassID int)
	
	-- Get newly added hierarchy class IDs
	insert into @updatedItems
	select il.itemID, 0, il.hierarchyClassID
	from @itemList il
	where	il.itemID not in
			(select itemID from @removeItemHierClassList)
		and
			il.hierarchyClassID not in
			(select hierarchyClassID from @removeItemHierClassList)

	-- Get updated hierarchy class IDs
	insert into @updatedItems
	select il.itemID, rihcl.itemID, il.itemID
	from @itemList il
	join @removeItemHierClassList rihcl 
		on il.itemID = rihcl.itemID

	--Return updated item IDs
	select itemID from @updatedItems

return
GO
PRINT N'Creating [app].[UpdateItemListByTrait]...';


GO

CREATE PROCEDURE [app].[UpdateItemListByTrait]
	@itemList app.ItemListByTraitType READONLY
AS

/*

We get a list of items and their traits (each different trait is a separate row),
so we update by linking the item and trait code coming in to the same fields in the ItemTrait table.

*/

declare @updatedItems table(
	itemID int,
	originalTraitValue nvarchar(255),
	newTraitValue nvarchar(255)
)

update ItemTrait
set traitValue = il.traitValue
output	inserted.itemID,
		deleted.traitValue,
		inserted.traitValue
into @updatedItems
from
	@itemList il
	join item i
		on il.itemID = i.itemID
	join ItemTrait it
		on i.itemID = it.itemID
where
	it.traitID = il.traitID -- Link trait names.

-- Return item IDs where the item's traits have changed.

select itemID
from @updatedItems ui
where ui.newTraitValue <> ui.originalTraitValue

return
GO
PRINT N'Creating [app].[AddEventQueue]...';


GO
CREATE PROCEDURE [app].[AddEventQueue]
	@EventName NVARCHAR(255), 
    @EventQueueEntries [app].[EventQueueEntriesType] READONLY,
	@RegionList [app].[RegionAbbrType] READONLY

AS
BEGIN
    SET NOCOUNT ON;

	BEGIN TRY;

		BEGIN TRANSACTION;

		----------------------------------------------
		-- Verify the EventType.EventName
		----------------------------------------------
		DECLARE @EventId INT;
		SELECT 	@EventId = (SELECT [EventId] FROM [app].[EventType] WHERE [EventName] = @EventName);

		IF @EventId IS NULL
		BEGIN
			-- RAISERROR with severity 11-19 will cause execution to jump to the CATCH block.
			RAISERROR('No EventName found matching the @EventName ''%s''!', 16, 1, @EventName);
		END

		----------------------------------------------
		-- Queue the Event
		----------------------------------------------
		DECLARE @eventCount INT, @regionCount INT
		SELECT @eventCount = (SELECT COUNT(*) FROM @EventQueueEntries)
		SELECT @regionCount = (SELECT COUNT(*) FROM @RegionList)

		IF (@eventCount > 0 AND @regionCount > 0) -- EVENTS AND REGIONS TO QUEUE UP
		BEGIN
			INSERT INTO [app].[EventQueue] ([EventId], [EventMessage], [EventReferenceId], [RegionCode])
			SELECT @EventId, e.EventMessage, e.EventReferenceId, r.RegionAbbr
			FROM @EventQueueEntries e 
			CROSS APPLY @RegionList r
		END
		ELSE IF (@eventCount > 0 AND @regionCount = 0)-- EVENTS, BUT NO REGIONS --> USE THE NULL REGION
		BEGIN
			INSERT INTO [app].[EventQueue] ([EventId], [EventMessage], [EventReferenceId], [RegionCode])
			SELECT @EventId, e.EventMessage, e.EventReferenceId, NULL
			FROM @EventQueueEntries e 
		END
		ELSE IF (@eventCount = 0 AND @regionCount > 0)-- NO EVENTS, BUT REGIONS
		BEGIN
			INSERT INTO [app].[EventQueue] ([EventId], [EventMessage], [EventReferenceId], [RegionCode])
			SELECT @EventId, NULL, NULL, r.RegionAbbr
			FROM @RegionList r
		END
		-- ELSE -- NO EVENTS AND NO REGIONS DO NOTHING

		IF @@TRANCOUNT > 0
			COMMIT TRANSACTION;

	END TRY
	BEGIN CATCH

		IF @@TRANCOUNT > 0
			ROLLBACK TRANSACTION;

		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		SET NOCOUNT OFF;

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH;

    SET NOCOUNT OFF;
END;
GO
PRINT N'Creating [app].[GenerateItemUpdateEvents]...';


GO
CREATE procedure [app].[GenerateItemUpdateEvents] 
	@updatedItemIDs app.UpdatedItemIDsType READONLY
as
	DECLARE @distinctItemIDs app.UpdatedItemIDsType,
			@itemUpdateEventType int,
			@validationDateTraitID int

	SET @itemUpdateEventType = 2
	SET @validationDateTraitID = 49
	
	INSERT @distinctItemIDs 
	SELECT DISTINCT itemID from @updatedItemIDs

	INSERT INTO app.EventQueue
	SELECT @itemUpdateEventType, sc.scanCode, dii.itemID, iis.regionCode, GETDATE()
	FROM @distinctItemIDs dii
	JOIN ScanCode sc
		ON sc.itemID = dii.itemID
	JOIN app.IRMAItemSubscription iis
		ON sc.scanCode = iis.identifier
	JOIN Item i
		ON sc.itemID = i.itemID
	JOIN ItemTrait it
		ON i.itemID = it.itemID
		AND it.traitID = @validationDateTraitID
	WHERE sc.scanCodeTypeID = 1
GO
PRINT N'Creating [app].[GenerateItemUpdateMessages]...';


GO

--************************************************************************
-- app.GenerateItemUpdateMessages
-- This stored procedure is called by the ItemImport.sql stored procedure.
-- This will generate a Product Message for the ESB for each itemID
-- that was updated in the ItemImport.sql stored proc
--************************************************************************

--************************************************************************
-- app.GenerateItemUpdateMessages
-- This stored procedure is called by the ItemImport.sql stored procedure.
-- This will generate a Product Message for the ESB for each itemID
-- that was updated in the ItemImport.sql stored proc
--************************************************************************

CREATE PROCEDURE [app].[GenerateItemUpdateMessages] 
	@updatedItemIDs app.UpdatedItemIDsType READONLY

AS

DECLARE @distinctItemIDs app.UpdatedItemIDsType;
INSERT @distinctItemIDs 
SELECT DISTINCT itemID FROM @updatedItemIDs

DECLARE
	@localeID int,
	@productDescriptionTraitID int,
	@posTraitID int,
	@packageUnitTraitID int,
	@foodStampEligibleTraitID int,
	@posScaleTareTraitID int,
	@departmentSaleTraitID int,
	@brandHierarchyID int,
	@browsingClassID int,
	@merchandisingClassID int,
	@financialClassID int,
	@taxClassID int,
	@validationDateTraitID int,
	@readyMessageStatusID int,
	@productMessageTypeID int,
	@merchFinMappingTraitID int;

SELECT @localeID = l.localeID FROM Locale l WHERE l.localeName = 'Whole Foods';
SELECT @productDescriptionTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Product Description';
SELECT @posTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Pos Description';
SELECT @packageUnitTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Package Unit';
SELECT @foodStampEligibleTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Food Stamp Eligible';
SELECT @posScaleTareTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Pos Scale Tare';
SELECT @departmentSaleTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Department Sale';
SELECT @brandHierarchyID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Brand';
SELECT @browsingClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Browsing';
SELECT @merchandisingClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Merchandising';
SELECT @financialClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Financial';
SELECT @taxClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Tax';
SELECT @validationDateTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Validation Date';
SELECT @readyMessageStatusID = s.MessageStatusId FROM app.MessageStatus s WHERE s.MessageStatusName = 'Ready';
SELECT @productMessageTypeID = t.MessageTypeId FROM app.MessageType t WHERE t.MessageTypeName = 'Product';
SELECT @merchFinMappingTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Merch Fin Mapping';

-- Get Browsing ItemHierarchyClass relationships for left join
select
	ihc.itemID,
	hc.hierarchyClassID,
	hc.hierarchyClassName,
	hc.hierarchyLevel,
	hc.hierarchyID,
	hc.hierarchyParentClassID
into #tempBrowsing
from
	ItemHierarchyClass		ihc
	JOIN HierarchyClass		hc on ihc.hierarchyClassID = hc.hierarchyClassID AND hc.hierarchyID = @browsingClassID
	JOIN @distinctItemIDs	i on ihc.itemID = i.itemID

-- Main
print 'Inserting into app.MessageQueueProduct'
INSERT INTO app.MessageQueueProduct
SELECT
	@productMessageTypeID			as MessageTypeID,
	@readyMessageStatusID			as MessageStatusID,
	NULL							as MessageHistoryID,
	dii.itemID						as ItemID,
	@localeID						as LocaleID,
	it.itemTypeCode					as ItemTypeCode,
	it.itemTypeDesc					as ItemTypeDesc,
	sc.scanCodeID					as ScanCodeID,
	sc.scanCode						as ScanCode,
	sct.scanCodeTypeID				as ScanCodeTypeID,
	sct.scanCodeTypeDesc			as ScanCodeTypeDesc,
	pd.traitValue					as ProductDescription,
	pos.traitValue					as PosDescription,
	pu.traitValue					as PackageUnit,
	fse.traitValue					as FoodStamp,
	posst.traitValue				as PosScaleTare,
	CASE 
		WHEN ds.traitValue IS NULL THEN '0'
		ELSE '1'
	END								as DepartmentSale,
	brandhc.hierarchyClassID		as BrandID,
	brandhc.hierarchyClassName		as BrandName,
	brandhc.hierarchyLevel			as BrandLevel,
	brandhc.hierarchyParentClassID	as BrandParentId,
	browhc.hierarchyClassID			as BrowsingId,
	browhc.hierarchyClassName		as BrowswingName,
	browhc.hierarchyLevel			as BrowsingLevel,
	browhc.hierarchyParentClassID	as BrowsingParentId,
	merchhc.hierarchyClassID		as MerchandisingId,
	merchhc.hierarchyClassName		as MerchandisingName,
	merchhc.hierarchyLevel			as MerchandisingLevel,
	merchhc.hierarchyParentClassID	as MerchandisingParentId,
	taxhc.hierarchyClassID			as TaxID,
	taxhc.hierarchyClassName		as TaxName,
	taxhc.hierarchyLevel			as TaxLevel,
	taxhc.hierarchyParentClassID	as TaxParentId,
	finhc.hierarchyClassID			as FinancialId,
	finhc.hierarchyClassName		as FinancialName,
	finhc.hierarchyLevel			as FinancialLevel,
	finhc.hierarchyParentClassID	as FinancialParentId,
	SYSDATETIME()					as InsertDate
FROM @distinctItemIDs dii
JOIN Item i
	ON dii.itemID = i.itemID
JOIN ItemType it
	ON i.itemTypeID = it.itemTypeID
JOIN ScanCode sc
	ON i.itemID = sc.itemID
JOIN ScanCodeType sct
	ON sc.scanCodeTypeID = sct.scanCodeTypeID
JOIN ItemTrait vdit
	ON i.itemID = vdit.itemID
	AND vdit.traitID = @validationDateTraitID -- Only generating messages for items that have been validated
JOIN ItemTrait pd
	ON i.itemID = pd.itemID
	AND pd.traitID = @productDescriptionTraitID
JOIN ItemTrait pos
	ON i.itemID = pos.itemID
	AND pos.traitID = @posTraitID
JOIN ItemTrait pu
	ON i.itemID = pu.itemID
	AND pu.traitID = @packageUnitTraitID
JOIN ItemTrait fse
	ON i.itemID = fse.itemID
	AND fse.traitID = @foodStampEligibleTraitID
JOIN ItemTrait posst
	ON i.itemID = posst.itemID
	AND posst.traitID = @posScaleTareTraitID
JOIN ItemHierarchyClass brandihc
	ON i.itemID = brandihc.itemID
JOIN HierarchyClass brandhc
	ON brandihc.hierarchyClassID = brandhc.hierarchyClassID
	AND brandhc.hierarchyID = @brandHierarchyID
JOIN ItemHierarchyClass ihcm
	ON i.itemID = ihcm.itemID
JOIN HierarchyClass merchhc
	ON ihcm.hierarchyClassID = merchhc.hierarchyClassID
	AND merchhc.hierarchyID = @merchandisingClassID
JOIN HierarchyClassTrait merchhct
	ON merchhc.hierarchyClassID = merchhct.HierarchyClassID
	AND merchhct.traitID = @merchFinMappingTraitID
JOIN HierarchyClass finhc
	ON merchhct.traitValue = finhc.hierarchyClassName
	AND finhc.hierarchyID = @financialClassID
JOIN ItemHierarchyClass ihct
	ON i.itemID = ihct.itemID
JOIN HierarchyClass taxhc
	ON ihct.hierarchyClassID = taxhc.hierarchyClassID
	AND taxhc.hierarchyID = @taxClassID
LEFT JOIN ItemTrait ds
	ON i.itemID = ds.itemID
	AND ds.traitID = @departmentSaleTraitID
LEFT JOIN #tempBrowsing browhc on i.itemID = browhc.itemID
GO
PRINT N'Creating [app].[UpdateTaxHierarchyClass]...';


GO
CREATE PROCEDURE [app].[UpdateTaxHierarchyClass] 
	@TaxHierarchyClasses app.TaxHierarchyClassUpdateType READONLY,  
	@Regions app.RegionAbbrType READONLY

AS
BEGIN

	SET NOCOUNT ON;
	
	BEGIN TRY;

		BEGIN TRANSACTION;

			DECLARE @IdToNameMap as TABLE
			(
				hierarchyClassID int,
				cchHierarchyClassID nvarchar(7),
				oldHierarchyClassName nvarchar(255),
				newHierarchyClassName nvarchar(255)
			);

			DECLARE @UpdatedTaxHierarchyClasses as Table
			(
				hierarchyClassID int,
				cchHierarchyClassID nvarchar(7),
				hierarchyClassName nvarchar(255)
			);

			DECLARE @NewTaxHierarchyClasses AS TABLE
			(
				hierarchyClassID int,
				cchHierarchyClassID nvarchar(7),
				hierarchyClassName nvarchar(255)
			);

			DECLARE @TaxHierarchyID int;
			SET @TaxHierarchyID = (SELECT hierarchyID FROM dbo.Hierarchy WHERE hierarchyName = 'Tax');

			----------------------------------------------------------------------
			-- Create a mapping between the Tax IDs and the HierarchyClass IDs
			----------------------------------------------------------------------
			INSERT	@IdToNameMap (hierarchyClassID, cchHierarchyClassID, oldHierarchyClassName, newHierarchyClassName)
			SELECT	hc.hierarchyClassID,
					thc.HierarchyClassID,
					hc.HierarchyClassName,
					thc.HierarchyClassName
			FROM	(SELECT hierarchyClassID, hierarchyClassName 
					 FROM dbo.HierarchyClass 
					 WHERE hierarchyId = @TaxHierarchyID) AS hc
			INNER JOIN @TaxHierarchyClasses thc ON hc.hierarchyClassName LIKE thc.HierarchyClassID + '%';

			----------------------------------------------------------------------
			-- Update current Tax HierarchyClasses
			----------------------------------------------------------------------
			INSERT @UpdatedTaxHierarchyClasses (hierarchyClassID, cchHierarchyClassID, hierarchyClassName)
			SELECT itnm.hierarchyClassID,
				   itnm.cchHierarchyClassID,
				   itnm.newHierarchyClassName
			FROM @IdToNameMap itnm
			WHERE itnm.oldHierarchyClassName <> itnm.newHierarchyClassName;
			
			UPDATE dbo.HierarchyClass
			SET hierarchyClassName = uthc.hierarchyClassName
			FROM dbo.HierarchyClass hc
			INNER JOIN @UpdatedTaxHierarchyClasses uthc
			ON hc.hierarchyClassID = uthc.hierarchyClassID;

			----------------------------------------------------------------------
			-- Add new Tax HierarchyClasses
			----------------------------------------------------------------------
			INSERT HierarchyClass 
				OUTPUT INSERTED.hierarchyClassID, NULL, INSERTED.hierarchyClassName
					INTO @NewTaxHierarchyClasses
			SELECT	1,
					@TaxHierarchyID,
					NULL,
					thc.hierarchyClassName 
			FROM @TaxHierarchyClasses thc
			WHERE thc.HierarchyClassName NOT IN (SELECT hierarchyClassName FROM @UpdatedTaxHierarchyClasses)
			AND thc.HierarchyClassName NOT IN (SELECT hierarchyClassName FROM dbo.[HierarchyClass]);

			-- Get the CCH hierarchyClassID to be used as the iCon.app.EventQueue.EventMessage
			UPDATE @NewTaxHierarchyClasses
			SET cchHierarchyClassID = thc.HierarchyClassID
			FROM @NewTaxHierarchyClasses nthc
			INNER JOIN @TaxHierarchyClasses thc ON nthc.hierarchyClassName = thc.HierarchyClassName

			----------------------------------------------------------------------
			-- Add Update Tax HierarchyClass events in EventQueue
			----------------------------------------------------------------------
			DECLARE @UpdateTaxEventQueueEntries app.EventQueueEntriesType;
			INSERT @UpdateTaxEventQueueEntries (EventMessage, EventReferenceId)
			SELECT cchHierarchyClassID, hierarchyClassID FROM @UpdatedTaxHierarchyClasses;

			IF ((SELECT COUNT(*) FROM @UpdatedTaxHierarchyClasses) > 0)
			BEGIN
				EXEC app.AddEventQueue 
					@EventName = 'Tax Name Update',
					@EventQueueEntries  = @UpdateTaxEventQueueEntries,
					@RegionList = @Regions;
			END

			----------------------------------------------------------------------
			-- Add New Tax HierarchyClass events in EventQueue
			----------------------------------------------------------------------			
			DECLARE @NewTaxEventQueueEntries app.EventQueueEntriesType;
			INSERT @NewTaxEventQueueEntries (EventMessage, EventReferenceId)
			SELECT cchHierarchyClassID, hierarchyClassID FROM @NewTaxHierarchyClasses;
			
			IF ((SELECT COUNT(*) FROM @NewTaxHierarchyClasses) > 0)
			BEGIN
				EXEC app.AddEventQueue 
					@EventName = 'New Tax Hierarchy',
					@EventQueueEntries  = @NewTaxEventQueueEntries,
					@RegionList = @Regions;
			END
			
			IF @@TRANCOUNT > 0
			COMMIT TRANSACTION;

	END TRY
	BEGIN CATCH

		IF @@TRANCOUNT > 0
			ROLLBACK TRANSACTION;

		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		SET NOCOUNT OFF;

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH;

    SET NOCOUNT OFF;
END;
GO
PRINT N'Altering [app].[ItemImport]...';


GO

ALTER PROCEDURE [app].[ItemImport]
	@itemList app.ItemImportType READONLY
	,@userName nvarchar(255)
AS
/*

	We receive a list of items and their traits in a single row.
	We build one list containing all the different traits for an item on separate rows.
	This way, we only call the update once, but the list could be larger than doing one trait at a time.
	We only include entries (in the to-be-updated list) where the current and new trait values differ.
	
*/


	declare @taskName varchar(32)
	select @taskName = 'iCon.ItemImport'

	declare @itemListByTrait ItemListByTraitType
	declare @targetTraitID int
	declare @localeID int set @localeID = 1

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding Product Desc changes to item-update list...';
	/*
		Update [Product Description]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'Product Description'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'Product Description',
			il.[Product Description]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[Product Description] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[Product Description] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding POS Desc changes to item-update list...';
	/*
		Update [POS Description]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'POS Description'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'POS Description',
			il.[POS Description]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[POS Description] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[POS Description] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding Pkg Unit changes to item-update list...';
	/*
		Update [Package Unit]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'Package Unit'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'Package Unit',
			il.[Package Unit]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[Package Unit] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[Package Unit] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding Food Stamp changes to item-update list...';
	/*
		Update [Food Stamp Eligible]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'Food Stamp Eligible'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'Food Stamp Eligible',
			il.[Food Stamp Eligible]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[Food Stamp Eligible] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[Food Stamp Eligible] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding POS Scale Tare changes to item-update list...';
	/*
		Update [POS Scale Tare]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'POS Scale Tare'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'POS Scale Tare',
			il.[POS Scale Tare]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[POS Scale Tare] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[POS Scale Tare] -- Only process entries where the current and new trait values differ.




	----------------------------------------------------------------------------
	----------------------------------------------------------------------------




	/*
		For item-hierarchy-class updates, we build a full list of target entries and pass that to an update procedure.
	*/

	declare
		@updateItemHierClassList ItemListByHierarchyClassType

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding brand hier changes to item-update list...';
	/*
		Add Brand Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Brand ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Brand ID] <> '' -- Ignore no-update entries.

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding browsing hier changes to item-update list...';
	/*
		Add Browsing Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Browsing Hierarchy ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Browsing Hierarchy ID] <> '' -- Ignore no-update entries.

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding merch hier changes to item-update list...';
	/*
		Add Merchandising Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Merchandising Hierarchy ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Merchandising Hierarchy ID] <> '' -- Ignore no-update entries.

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding tax hier changes to item-update list...';
	/*
		Add Tax Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Tax Class ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Tax Class ID] <> '' -- Ignore no-update entries.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


-- All or nothing update.
begin tran
begin try


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	declare @updatedItemIDs app.UpdatedItemIDsType


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Applying item-trait updates...';
	/*
	
		****** APPLY TRAIT UPDATES ******

	*/
	insert @updatedItemIDs
	exec app.UpdateItemListByTrait @itemListByTrait


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Applying item-hier updates...';
	/*
	
		****** APPLY HIERARCHY UPDATES ******

	*/
	insert @updatedItemIDs
	exec app.UpdateItemHierarchyClass @updateItemHierClassList


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Generating item update events...';
	/*

		****** GENERATING ITEM UPDATE EVENTS ******

	*/	
	exec app.GenerateItemUpdateEvents @updatedItemIDs


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Generating messages for ESB...';
	/*

		****** GENERATING MESSAGES FOR ESB ******

	*/	
	exec app.GenerateItemUpdateMessages @updatedItemIDs

	if @@TRANCOUNT > 0
	begin
		print '-------------------------------------------------';
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Committing ' + cast(@@TRANCOUNT as varchar) + ' transaction(s)...';
		COMMIT TRANSACTION
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Updates committed successfully.';
		print '-------------------------------------------------';
	end
	else
	begin
		PRINT '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + '**Warning** -- No updates to commit.';
	end
end try
begin catch
	IF @@TRANCOUNT > 0
	begin
		print '-------------------------------------------------';
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Performing transaction rollback...';
		ROLLBACK TRANSACTION
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Rollback complete.';
		print '-------------------------------------------------';
	end
	else
	begin
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + '**Nothing to rollback.';
	end

	DECLARE @ErrorMessage NVARCHAR(4000);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	SELECT
		@ErrorMessage = 'An error occurred.  Database changes were rolled back.
Tran count: ' + cast(@@TRANCOUNT as varchar) + '
Error: ''' + isnull(ERROR_MESSAGE(), '[no error msg]') + '''
Procedure: ' + isnull(ERROR_PROCEDURE(), '[no error procedure]') + '
Line: ' + cast(isnull(ERROR_LINE(), '[no error line]') as varchar)
		,@ErrorSeverity = ERROR_SEVERITY()
		,@ErrorState = ERROR_STATE()

	-- Rethrow error so caller gets message.
    RAISERROR (
		@ErrorMessage -- Message text.
		,@ErrorSeverity -- Severity.
		,@ErrorState -- State.
	)

end catch
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [app].[MessageException] WITH CHECK CHECK CONSTRAINT [FK_MessageException_MessageHistoryId];

ALTER TABLE [app].[MessageHistory] WITH CHECK CHECK CONSTRAINT [FK_MessageHistory_MessageStatus];

ALTER TABLE [app].[MessageHistory] WITH CHECK CHECK CONSTRAINT [FK_MessageHistory_MessageType];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageActionId];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageHistoryId];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageStatusId];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageTypeId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageTypeId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageStatusId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageHistoryId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_IRMAPushID];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageActionId];

ALTER TABLE [app].[MessageQueueLocale] WITH CHECK CHECK CONSTRAINT [FK_app.MessageQueueLocale_MessageType];

ALTER TABLE [app].[MessageQueueLocale] WITH CHECK CHECK CONSTRAINT [FK_app.MessageQueueLocale_MessageStatus];

ALTER TABLE [app].[MessageQueueLocale] WITH CHECK CHECK CONSTRAINT [FK_app.MessageQueueLocale_MessageHistory];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_MessageTypeID];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_MessageStatusId];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_MessageHistoryId];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_IRMAPushID];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_UomCode];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_CurrencyCode];

ALTER TABLE [app].[MessageQueueProduct] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueProduct_MessageStatusId];

ALTER TABLE [app].[MessageQueueProduct] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueProduct_MessageTypeId];

ALTER TABLE [app].[MessageQueueProduct] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueProduct_MessageHistoryId];


GO
PRINT N'Update complete.';


GO
