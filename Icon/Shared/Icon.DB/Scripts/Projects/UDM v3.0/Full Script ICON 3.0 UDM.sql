-- FULL SCRIPT FOR ICON UDM 3.0 
-- MUST BE RUN IN SQL COMMAND MODE

-- Task 3343

--Party
EXEC sp_rename N'[dbo].[PartyType].[partyTypeCode]', N'partyTypeID', N'Column'
EXEC sp_rename N'[dbo].[OrganizationType].[orgTypeCode]', N'orgTypeID', N'Column'
-- keys
EXEC sp_rename N'[dbo].[Party].[partyTypeCode]', N'partyTypeID', N'Column'
EXEC sp_rename N'[dbo].[Organization].[orgTypeCode]', N'orgTypeID', N'Column'

--Location
EXEC sp_rename N'[dbo].[LocaleType].[localeTypeCode]', N'localeTypeID', N'Column'
EXEC sp_rename N'[dbo].[Trait].[traitCode]', N'traitID', N'Column'
EXEC sp_rename N'[dbo].[UOM].[uomCode]', N'uomID', N'Column'
-- keys
EXEC sp_rename N'[dbo].[Locale].[localeTypeCode]', N'localeTypeID', N'Column'
EXEC sp_rename N'[dbo].[LocaleTrait].[traitCode]', N'traitID', N'Column'
EXEC sp_rename N'[dbo].[LocaleTrait].[uomCode]', N'uomID', N'Column'

--Item
EXEC sp_rename N'[dbo].[TraitGroup].[traitGroupCode]', N'traitGroupID', N'Column'
EXEC sp_rename N'[dbo].[ItemType].[itemTypeCode]', N'itemTypeID', N'Column'
-- keys
EXEC sp_rename N'[dbo].[Trait].[traitGroupCode]', N'traitGroupID', N'Column'
EXEC sp_rename N'[dbo].[Item].[itemTypeCode]', N'itemTypeID', N'Column'
EXEC sp_rename N'[dbo].[ItemTrait].[traitCode]', N'traitID', N'Column'
EXEC sp_rename N'[dbo].[ItemTrait].[uomCode]', N'uomID', N'Column'

--Price
EXEC sp_rename N'[dbo].[ItemPriceType].[itemPriceTypeCode]', N'itemPriceTypeID', N'Column'
EXEC sp_rename N'[dbo].[CurrencyType].[currencyTypeCode]', N'currencyTypeID', N'Column'
-- keys
EXEC sp_rename N'[dbo].[ItemPrice].[uomCode]', N'uomID', N'Column'
EXEC sp_rename N'[dbo].[ItemPrice].[itemPriceTypeCode]', N'itemPriceTypeID', N'Column'
EXEC sp_rename N'[dbo].[ItemPrice].[currencyTypeCode]', N'currencyTypeID', N'Column'

-- end first script

-- Task 3343

/*
Deployment script for IconWurk2

This code was generated by a tool.  << yeah it was.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "IconTestStage2"
:setvar DefaultFilePrefix "IconTestStage2"
:setvar DefaultDataPath "E:\SQL_DATA"
:setvar DefaultLogPath "E:\SQL_LOGS"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Dropping Country_PhysicalAddress_FK1...';


GO
ALTER TABLE [dbo].[PhysicalAddress] DROP CONSTRAINT [Country_PhysicalAddress_FK1];


GO
PRINT N'Dropping Country_PostalCode_FK1...';


GO
ALTER TABLE [dbo].[PostalCode] DROP CONSTRAINT [Country_PostalCode_FK1];


GO
PRINT N'Dropping Country_Territory_FK1...';


GO
ALTER TABLE [dbo].[Territory] DROP CONSTRAINT [Country_Territory_FK1];


GO
PRINT N'Dropping CurrencyType_ItemPrice_FK1...';


GO
ALTER TABLE [dbo].[ItemPrice] DROP CONSTRAINT [CurrencyType_ItemPrice_FK1];


GO
PRINT N'Dropping UOM_ItemPrice_FK1...';


GO
ALTER TABLE [dbo].[ItemPrice] DROP CONSTRAINT [UOM_ItemPrice_FK1];


GO
PRINT N'Dropping ItemPriceType_ItemPrice_FK1...';


GO
ALTER TABLE [dbo].[ItemPrice] DROP CONSTRAINT [ItemPriceType_ItemPrice_FK1];


GO
PRINT N'Dropping UOM_ItemTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemTrait] DROP CONSTRAINT [UOM_ItemTrait_FK1];


GO
PRINT N'Dropping ItemType_Item_FK1...';


GO
ALTER TABLE [dbo].[Item] DROP CONSTRAINT [ItemType_Item_FK1];


GO
PRINT N'Dropping UOM_LocaleTrait_FK1...';


GO
ALTER TABLE [dbo].[LocaleTrait] DROP CONSTRAINT [UOM_LocaleTrait_FK1];


GO
PRINT N'Dropping LocaleType_Locale_FK1...';


GO
ALTER TABLE [dbo].[Locale] DROP CONSTRAINT [LocaleType_Locale_FK1];


GO
PRINT N'Dropping Organization_Locale_FK1...';


GO
ALTER TABLE [dbo].[Locale] DROP CONSTRAINT [Organization_Locale_FK1];


GO
PRINT N'Dropping Party_Organization_FK1...';


GO
ALTER TABLE [dbo].[Organization] DROP CONSTRAINT [Party_Organization_FK1];


GO
PRINT N'Dropping Organization_Organization_FK1...';


GO
ALTER TABLE [dbo].[Organization] DROP CONSTRAINT [Organization_Organization_FK1];


GO
PRINT N'Dropping OrganizationType_Organization_FK1...';


GO
ALTER TABLE [dbo].[Organization] DROP CONSTRAINT [OrganizationType_Organization_FK1];


GO
PRINT N'Dropping Organization_OrganizationName_FK1...';


GO
ALTER TABLE [dbo].[OrganizationName] DROP CONSTRAINT [Organization_OrganizationName_FK1];


GO
PRINT N'Dropping PartyType_Party_FK1...';


GO
ALTER TABLE [dbo].[Party] DROP CONSTRAINT [PartyType_Party_FK1];


GO
PRINT N'Dropping PostalCode_PhysicalAddress_FK1...';


GO
ALTER TABLE [dbo].[PhysicalAddress] DROP CONSTRAINT [PostalCode_PhysicalAddress_FK1];


GO
PRINT N'Dropping County_PostalCode_FK1...';


GO
ALTER TABLE [dbo].[PostalCode] DROP CONSTRAINT [County_PostalCode_FK1];


GO
PRINT N'Dropping Trait_ItemTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemTrait] DROP CONSTRAINT [Trait_ItemTrait_FK1];


GO
PRINT N'Dropping Trait_LocaleTrait_FK1...';


GO
ALTER TABLE [dbo].[LocaleTrait] DROP CONSTRAINT [Trait_LocaleTrait_FK1];


GO
PRINT N'Dropping TraitGroup_Trait_FK1...';


GO
ALTER TABLE [dbo].[Trait] DROP CONSTRAINT [TraitGroup_Trait_FK1];


--GO
--PRINT N'Creating [WFM\TFSAdmin]...';

GO
PRINT N'Starting rebuilding table [dbo].[Country]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_Country] (
    [countryCode] NVARCHAR (3)   NOT NULL,
    [countryName] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_Country_PK] PRIMARY KEY CLUSTERED ([countryCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[Country])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_Country] ([countryCode], [countryName])
        SELECT   [countryCode],
                 [countryName]
        FROM     [dbo].[Country]
        ORDER BY [countryCode] ASC;
    END

DROP TABLE [dbo].[Country];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_Country]', N'Country';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_Country_PK]', N'Country_PK', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
/*
The column [dbo].[CurrencyType].[currencyTypeCode] on table [dbo].[CurrencyType] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'Starting rebuilding table [dbo].[CurrencyType]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_CurrencyType] (
    [currencyTypeID]   INT            IDENTITY (1, 1) NOT NULL,
    [currencyTypeCode] NVARCHAR (3)   NOT NULL,
    [currencyTypeDesc] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_CurrencyType_PK] PRIMARY KEY CLUSTERED ([currencyTypeID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_currencyTypeCode_currencyTypeCode] UNIQUE NONCLUSTERED ([currencyTypeCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[CurrencyType])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_CurrencyType] ON;
        INSERT INTO [dbo].[tmp_ms_xx_CurrencyType] ([currencyTypeID], [currencyTypeDesc])
        SELECT   [currencyTypeID],
                 [currencyTypeDesc]
        FROM     [dbo].[CurrencyType]
        ORDER BY [currencyTypeID] ASC;
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_CurrencyType] OFF;
    END

DROP TABLE [dbo].[CurrencyType];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_CurrencyType]', N'CurrencyType';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_CurrencyType_PK]', N'CurrencyType_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_currencyTypeCode_currencyTypeCode]', N'AK_currencyTypeCode_currencyTypeCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[ItemPrice]...';


GO
ALTER TABLE [dbo].[ItemPrice] ALTER COLUMN [uomID] INT NOT NULL;


GO
/*
The column [dbo].[ItemPriceType].[itemPriceTypeCode] on table [dbo].[ItemPriceType] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'Starting rebuilding table [dbo].[ItemPriceType]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_ItemPriceType] (
    [itemPriceTypeID]   INT            IDENTITY (1, 1) NOT NULL,
    [itemPriceTypeCode] NVARCHAR (3)   NOT NULL,
    [itemPriceTypeDesc] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_ItemPriceType_PK] PRIMARY KEY CLUSTERED ([itemPriceTypeID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_itemPriceTypeCode_itemPriceTypeCode] UNIQUE NONCLUSTERED ([itemPriceTypeCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[ItemPriceType])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_ItemPriceType] ON;
        INSERT INTO [dbo].[tmp_ms_xx_ItemPriceType] ([itemPriceTypeID], [itemPriceTypeDesc])
        SELECT   [itemPriceTypeID],
                 [itemPriceTypeDesc]
        FROM     [dbo].[ItemPriceType]
        ORDER BY [itemPriceTypeID] ASC;
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_ItemPriceType] OFF;
    END

DROP TABLE [dbo].[ItemPriceType];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_ItemPriceType]', N'ItemPriceType';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_ItemPriceType_PK]', N'ItemPriceType_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_itemPriceTypeCode_itemPriceTypeCode]', N'AK_itemPriceTypeCode_itemPriceTypeCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[ItemTrait]...';


GO
ALTER TABLE [dbo].[ItemTrait] ALTER COLUMN [uomID] INT NULL;


GO
/*
The column [dbo].[ItemType].[itemTypeCode] on table [dbo].[ItemType] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'***Hack #1*** Starting rebuilding table [dbo].[ItemType]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_ItemType] (
    [itemTypeID]   INT            IDENTITY (1, 1) NOT NULL,
    [itemTypeCode] NVARCHAR (3)   NOT NULL,
    [itemTypeDesc] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_ItemType_PK] PRIMARY KEY CLUSTERED ([itemTypeID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_itemTypeCode_itemTypeCode] UNIQUE NONCLUSTERED ([itemTypeCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[ItemType])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_ItemType] ON;
        --INSERT INTO [dbo].[tmp_ms_xx_ItemType] ([itemTypeID], [itemTypeDesc])
        --SELECT   [itemTypeID],
        --         [itemTypeDesc]
        --FROM     [dbo].[ItemType]
        --ORDER BY [itemTypeID] ASC;
         INSERT INTO [dbo].[tmp_ms_xx_ItemType] ([itemTypeID], [itemTypeCode], [itemTypeDesc]) VALUES (1, 'RTL', N'Retail Sale')
         INSERT INTO [dbo].[tmp_ms_xx_ItemType] ([itemTypeID], [itemTypeCode], [itemTypeDesc]) VALUES (2, 'DEP', N'Deposit')
         INSERT INTO [dbo].[tmp_ms_xx_ItemType] ([itemTypeID], [itemTypeCode], [itemTypeDesc]) VALUES (3, 'TAR', N'Tare')
         SET IDENTITY_INSERT [dbo].[tmp_ms_xx_ItemType] OFF;
    END

DROP TABLE [dbo].[ItemType];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_ItemType]', N'ItemType';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_ItemType_PK]', N'ItemType_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_itemTypeCode_itemTypeCode]', N'AK_itemTypeCode_itemTypeCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[LocaleTrait]...';


GO
ALTER TABLE [dbo].[LocaleTrait] ALTER COLUMN [uomID] INT NULL;


GO
/*
The column [dbo].[LocaleType].[localeTypeCode] on table [dbo].[LocaleType] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'***Hack #2*** Starting rebuilding table [dbo].[LocaleType]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_LocaleType] (
    [localeTypeID]   INT            IDENTITY (1, 1) NOT NULL,
    [localeTypeCode] NVARCHAR (3)   NOT NULL,
    [localeTypeDesc] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_LocaleType_PK] PRIMARY KEY CLUSTERED ([localeTypeID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_localeTypeCode_localeTypeCode] UNIQUE NONCLUSTERED ([localeTypeCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[LocaleType])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_LocaleType] ON;
        --INSERT INTO [dbo].[tmp_ms_xx_LocaleType] ([localeTypeID], [localeTypeDesc])
        --SELECT   [localeTypeID],
        --         [localeTypeDesc]
        --FROM     [dbo].[LocaleType]
        --ORDER BY [localeTypeID] ASC;
        INSERT INTO [dbo].[tmp_ms_xx_LocaleType] ([localeTypeID], [localeTypeCode], [localeTypeDesc]) VALUES (1, 'CH', N'Chain')
        INSERT INTO [dbo].[tmp_ms_xx_LocaleType] ([localeTypeID], [localeTypeCode], [localeTypeDesc]) VALUES (2, 'RG', N'Region')
        INSERT INTO [dbo].[tmp_ms_xx_LocaleType] ([localeTypeID], [localeTypeCode], [localeTypeDesc]) VALUES (3, 'MT', N'Metro')
        INSERT INTO [dbo].[tmp_ms_xx_LocaleType] ([localeTypeID], [localeTypeCode], [localeTypeDesc]) VALUES (4, 'ST', N'Store')
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_LocaleType] OFF;
    END

DROP TABLE [dbo].[LocaleType];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_LocaleType]', N'LocaleType';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_LocaleType_PK]', N'LocaleType_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_localeTypeCode_localeTypeCode]', N'AK_localeTypeCode_localeTypeCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'***Hack #3***  Starting rebuilding table [dbo].[Organization]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_Organization] (
    [orgPartyID]       INT            IDENTITY (1, 1) NOT NULL,
    [orgTypeID]        INT            NULL,
    [parentOrgPartyID] INT            NULL,
    [orgDesc]          NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_Organization_PK] PRIMARY KEY CLUSTERED ([orgPartyID] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[Organization])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_Organization] ON;
        --INSERT INTO [dbo].[tmp_ms_xx_Organization] ([orgPartyID], [orgTypeID], [parentOrgPartyID], [orgDesc])
        --SELECT   [orgPartyID],
        --         [orgTypeID],
        --         [parentOrgPartyID],
        --         [orgDesc]
        --FROM     [dbo].[Organization]
        --ORDER BY [orgPartyID] ASC;
        INSERT INTO [dbo].[tmp_ms_xx_Organization] ([orgPartyID], [orgTypeID], [parentOrgPartyID], [orgDesc]) VALUES (1, 1, NULL, N'Whole Foods')
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_Organization] OFF;
    END

DROP TABLE [dbo].[Organization];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_Organization]', N'Organization';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_Organization_PK]', N'Organization_PK', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
/*
The column [dbo].[OrganizationType].[orgTypeCode] on table [dbo].[OrganizationType] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'***Hack #4***  Starting rebuilding table [dbo].[OrganizationType]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_OrganizationType] (
    [orgTypeID]   INT            IDENTITY (1, 1) NOT NULL,
    [orgTypeCode] NVARCHAR (3)   NOT NULL,
    [orgTypeDesc] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_OrganizationType_PK] PRIMARY KEY CLUSTERED ([orgTypeID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_orgTypeCode_orgTypeCode] UNIQUE NONCLUSTERED ([orgTypeCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[OrganizationType])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_OrganizationType] ON;
        --INSERT INTO [dbo].[tmp_ms_xx_OrganizationType] ([orgTypeID], [orgTypeDesc])
        --SELECT   [orgTypeID],
        --         [orgTypeDesc]
        --FROM     [dbo].[OrganizationType]
        --ORDER BY [orgTypeID] ASC;
        INSERT INTO [dbo].[tmp_ms_xx_OrganizationType] ([orgTypeID], [orgTypeCode], [orgTypeDesc]) VALUES (1, 'RT', N'Retailer')
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_OrganizationType] OFF;
    END

DROP TABLE [dbo].[OrganizationType];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_OrganizationType]', N'OrganizationType';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_OrganizationType_PK]', N'OrganizationType_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_orgTypeCode_orgTypeCode]', N'AK_orgTypeCode_orgTypeCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
/*
The column [dbo].[PartyType].[partyTypeCode] on table [dbo].[PartyType] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'***Hack #5***  Starting rebuilding table [dbo].[PartyType]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_PartyType] (
    [partyTypeID]   INT            IDENTITY (1, 1) NOT NULL,
    [partyTypeCode] NVARCHAR (3)   NOT NULL,
    [partyTypeDesc] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PartyType_PK] PRIMARY KEY CLUSTERED ([partyTypeID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_partyTypeCode_partyTypeCode] UNIQUE NONCLUSTERED ([partyTypeCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[PartyType])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_PartyType] ON;
        --INSERT INTO [dbo].[tmp_ms_xx_PartyType] ([partyTypeID], [partyTypeDesc])
        --SELECT   [partyTypeID],
        --         [partyTypeDesc]
        --FROM     [dbo].[PartyType]
        --ORDER BY [partyTypeID] ASC;
        INSERT INTO [dbo].[tmp_ms_xx_PartyType] ([partyTypeID], [partyTypeCode], [partyTypeDesc]) VALUES (1, 'ORG', N'Organization')
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_PartyType] OFF;
    END

DROP TABLE [dbo].[PartyType];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_PartyType]', N'PartyType';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PartyType_PK]', N'PartyType_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_partyTypeCode_partyTypeCode]', N'AK_partyTypeCode_partyTypeCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[PhysicalAddress]...';


GO
ALTER TABLE [dbo].[PhysicalAddress] ALTER COLUMN [countryCode] NVARCHAR (3) NULL;


GO
PRINT N'Starting rebuilding table [dbo].[PostalCode]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_PostalCode] (
    [postalCode]  INT          NOT NULL,
    [countryCode] NVARCHAR (3) NOT NULL,
    [countyCode]  INT          NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PostalCode_PK] PRIMARY KEY CLUSTERED ([postalCode] ASC, [countryCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[PostalCode])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_PostalCode] ([postalCode], [countryCode], [countyCode])
        SELECT   [postalCode],
                 [countryCode],
                 [countyCode]
        FROM     [dbo].[PostalCode]
        ORDER BY [postalCode] ASC, [countryCode] ASC;
    END

DROP TABLE [dbo].[PostalCode];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_PostalCode]', N'PostalCode';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PostalCode_PK]', N'PostalCode_PK', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[Territory]...';


GO
ALTER TABLE [dbo].[Territory] ALTER COLUMN [countryCode] NVARCHAR (3) NOT NULL;


GO
PRINT N'***Hack #6***  Starting rebuilding table [dbo].[TraitGroup]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_TraitGroup] (
    [traitGroupID]   INT            IDENTITY (1, 1) NOT NULL,
    [traitGroupCode] NVARCHAR (3)   NOT NULL,
    [traitGroupDesc] NVARCHAR (255) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_TraitGroup_PK] PRIMARY KEY CLUSTERED ([traitGroupID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_traitGroupCode_traitGroupCode] UNIQUE NONCLUSTERED ([traitGroupCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[TraitGroup])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_TraitGroup] ON;
        --INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc])
        --SELECT   [traitGroupID],
        --         [traitGroupDesc]
        --FROM     [dbo].[TraitGroup]
        --ORDER BY [traitGroupID] ASC;
        INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc]) VALUES (1,'IA', N'Item Attributes')
        INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc]) VALUES (2,'ILA', N'Item-Locale Attributes')
        INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc]) VALUES (3,'PA', N'Price Attributes')
        INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc]) VALUES (4,'ECA', N'eCommerce Attributes')
        INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc]) VALUES (5,'LT', N'Locale Traits')
        INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc]) VALUES (6,'HT', N'History Traits')
        INSERT INTO [dbo].[tmp_ms_xx_TraitGroup] ([traitGroupID], [traitGroupCode], [traitGroupDesc]) VALUES (7,'HYT', N'Hierarchy Traits')
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_TraitGroup] OFF;
    END

DROP TABLE [dbo].[TraitGroup];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_TraitGroup]', N'TraitGroup';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_TraitGroup_PK]', N'TraitGroup_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_traitGroupCode_traitGroupCode]', N'AK_traitGroupCode_traitGroupCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO

/*
The column [dbo].[Trait].[traitCode] on table [dbo].[Trait] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'***Hack #7***  Starting rebuilding table [dbo].[Trait]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_Trait] (
    [traitID]      INT            IDENTITY (1, 1) NOT NULL,
    [traitCode]    NVARCHAR (3)   NOT NULL,
    [traitPattern] NVARCHAR (255) NOT NULL,
    [traitDesc]    NVARCHAR (255) NULL,
    [traitGroupID] INT            NULL,
    CONSTRAINT [tmp_ms_xx_constraint_Trait_PK] PRIMARY KEY CLUSTERED ([traitID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_traitCode_traitCode] UNIQUE NONCLUSTERED ([traitCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[Trait])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_Trait] ON;
        --INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitPattern], [traitDesc], [traitGroupID])
        --SELECT   [traitID],
        --         [traitPattern],
        --         [traitDesc],
        --         [traitGroupID]
        --FROM     [dbo].[Trait]
        --ORDER BY [traitID] ASC;
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('0','PRD', N'^[a-zA-Z0-9_]*$', N'Product Description', (select traitGroupID from traitgroup where traitGroupCode = 'IA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('1','POS', N'^[a-zA-Z0-9_]*$', N'POS Description', (select traitGroupID from traitgroup where traitGroupCode = 'IA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('2','PKG', N'^[0-9]*\.?[0-9]+$', N'Package Unit', (select traitGroupID from traitgroup where traitGroupCode = 'IA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('3','FSE', N'0|1', N'Food Stamp Eligible', (select traitGroupID from traitgroup where traitGroupCode = 'IA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('4','SCT', N'0|1', N'POS Scale Tare', (select traitGroupID from traitgroup where traitGroupCode = 'IA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('5','DPT', N'0|1', N'Department Sale', (select traitGroupID from traitgroup where traitGroupCode = 'IA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('6','GFT', N'0|1', N'Gift Card', (select traitGroupID from traitgroup where traitGroupCode = 'IA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('7','RSZ', N'^[0-9]*\.?[0-9]+$', N'Retail Size', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('8','RUM', N'^[0-9]*\.?[0-9]+$', N'Retail UOM', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('9','TMD', N'0|1', N'TM Discount Eligible', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('10','CSD', N'0|1', N'Case Discount Eligible', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('11','PRH', N'0|1', N'Prohibit Discount', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('12','AGE', N'^[0-9]*\.?[0-9]+$', N'Age Restrict', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('13','RCL', N'0|1', N'Recall', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('14','RES', N'^[0-9]*\.?[0-9]+$', N'Restricted Hours', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('15','SBW', N'0|1', N'Sold by Weight', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('16','FCT', N'0|1', N'Force Tare', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('17','QTY', N'0|1', N'Quantity Required', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('18','PRQ', N'0|1', N'Price Required', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('19','QPR', N'^[0-9]*\.?[0-9]+$', N'Quantity Prohibit', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('20','VV', N'0|1', N'Visual Verify', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('21','RS', N'0|1', N'Restrict Sale', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('22','NA', N'0|1', N'Not Authorized For Sale', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('23','DEL', N'0|1', N'Delete', (select traitGroupID from traitgroup where traitGroupCode = 'ILA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('24','LOC', N'^[0-9]*\.?[0-9]+$', N'Locale', (select traitGroupID from traitgroup where traitGroupCode = 'PA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('25','PRC', N'^[0-9]*\.?[0-9]+$', N'Price', (select traitGroupID from traitgroup where traitGroupCode = 'PA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('26','PM', N'^[0-9]*\.?[0-9]+$', N'Price Multiple', (select traitGroupID from traitgroup where traitGroupCode = 'PA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('27','ST', N'^(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.](19|20)\d\d$', N'Price Start Date', (select traitGroupID from traitgroup where traitGroupCode = 'PA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('28','END', N'^(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.](19|20)\d\d$', N'Price End Date', (select traitGroupID from traitgroup where traitGroupCode = 'PA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('29','SHT', N'^[a-zA-Z0-9_]*$', N'Short Romance', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('30','LNG', N'^[a-zA-Z0-9_]*$', N'Long Romance', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('31','GF', N'0|1', N'Gluten Free', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('32','PBC', N'0|1', N'Premium Body Care', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('33','EX', N'0|1', N'Exclusive', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('34','WT', N'0|1', N'Whole Trade', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('35','NGM', N'0|1', N'Non GMO', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('36','HSH', N'0|1', N'HSH', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('37','E2', N'0|1', N'E2', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('38','VGN', N'0|1', N'Vegan', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('39','VEG', N'0|1', N'Vegetarian', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('40','KSH', N'0|1', N'Kosher', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('41','ECO', N'Baseline|Premium|Ultra-Premium', N'ECO Scale Rating', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('42','OG', N'0|1', N'Organic', (select traitGroupID from traitgroup where traitGroupCode = 'ECA'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('43','ABB', N'^[a-zA-Z0-9_]*$', N'Region Abbreviation', (select traitGroupID from traitgroup where traitGroupCode = 'LT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('44','BU', N'^[a-zA-Z0-9_]*$', N'PS Business Unit ID', (select traitGroupID from traitgroup where traitGroupCode = 'LT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('45','VER', N'^[0-9]*\.?[0-9]+$', N'ScanCode Version', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('46','INS', N'^(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.](19|20)\d\d$', N'Insert Date', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('47','MOD', N'^(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.](19|20)\d\d$', N'Modified Date', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('48','VAL', N'^(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.](19|20)\d\d$', N'Validation Date', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('49','MFM', N'^[a-zA-Z0-9_]*$', N'Merch Fin Mapping', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('50','GL', N'^[a-zA-Z0-9_]*$', N'GL Account', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('51','ABR', N'^[a-zA-Z0-9_]*$', N'Tax Abbreviation', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('52','SBC', N'^[a-zA-Z0-9_]*$', N'Sub Brick Code', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
INSERT INTO [dbo].[tmp_ms_xx_Trait] ([traitID], [traitCode], [traitPattern], [traitDesc], [traitGroupID]) VALUES ('53','FIN', N'^[a-zA-Z0-9_]*$', N'Financial Hierarchy Code', (select traitGroupID from traitgroup where traitGroupCode = 'HT'))
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_Trait] OFF;
    END

DROP TABLE [dbo].[Trait];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_Trait]', N'Trait';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_Trait_PK]', N'Trait_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_traitCode_traitCode]', N'AK_traitCode_traitCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
/*
The column [dbo].[TraitGroup].[traitGroupCode] on table [dbo].[TraitGroup] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
/*
The column [dbo].[UOM].[uomCode] on table [dbo].[UOM] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.

The type for column uomID in table [dbo].[UOM] is currently  NVARCHAR (5) NOT NULL but is being changed to  INT NOT NULL. Data loss could occur.
*/
GO
PRINT N'Starting rebuilding table [dbo].[UOM]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_UOM] (
    [uomID]   INT            NOT NULL,
    [uomCode] NVARCHAR (3)   NOT NULL,
    [uomName] NVARCHAR (100) NULL,
    CONSTRAINT [tmp_ms_xx_constraint_UOM_PK] PRIMARY KEY CLUSTERED ([uomID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [tmp_ms_xx_constraint_AK_uomCode_uomCode] UNIQUE NONCLUSTERED ([uomCode] ASC) WITH (FILLFACTOR = 80)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[UOM])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_UOM] ([uomID], [uomName])
        SELECT   [uomID],
                 [uomName]
        FROM     [dbo].[UOM]
        ORDER BY [uomID] ASC;
    END

DROP TABLE [dbo].[UOM];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_UOM]', N'UOM';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_UOM_PK]', N'UOM_PK', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_AK_uomCode_uomCode]', N'AK_uomCode_uomCode', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating [app].[AppConfig]...';


GO
CREATE TABLE [app].[AppConfig] (
    [Id]            INT            IDENTITY (1, 1) NOT NULL,
    [Region]        NVARCHAR (2)   NOT NULL,
    [Configuration] NVARCHAR (255) NOT NULL,
    [Enabled]       BIT            NOT NULL,
    CONSTRAINT [PK_Id] PRIMARY KEY CLUSTERED ([Id] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'***Hack #8***  Changing dbo.plumap to [app].[PLUMap]...';

ALTER SCHEMA app TRANSFER [dbo].[PLUMap]
--GO
--CREATE TABLE [app].[PLUMap] (
--    [itemID] INT           NOT NULL,
--    [flPLU]  NVARCHAR (11) NULL,
--    [maPLU]  NVARCHAR (11) NULL,
--    [mwPLU]  NVARCHAR (11) NULL,
--    [naPLU]  NVARCHAR (11) NULL,
--    [ncPLU]  NVARCHAR (11) NULL,
--    [nePLU]  NVARCHAR (11) NULL,
--    [pnPLU]  NVARCHAR (11) NULL,
--    [rmPLU]  NVARCHAR (11) NULL,
--    [soPLU]  NVARCHAR (11) NULL,
--    [spPLU]  NVARCHAR (11) NULL,
--    [swPLU]  NVARCHAR (11) NULL,
--    [ukPLU]  NVARCHAR (11) NULL,
--    CONSTRAINT [PLUMap_PK] PRIMARY KEY CLUSTERED ([itemID] ASC) WITH (FILLFACTOR = 80)
--);


--GO
PRINT N'Creating [dbo].[HierarchyClassTrait]...';


GO
CREATE TABLE [dbo].[HierarchyClassTrait] (
    [traitID]          INT            NOT NULL,
    [hierarchyClassID] INT            NOT NULL,
    [uomID]            INT            NULL,
    [traitValue]       NVARCHAR (255) NULL,
    CONSTRAINT [HierarchyClassTrait_PK] PRIMARY KEY CLUSTERED ([traitID] ASC, [HierarchyClassID] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [dbo].[ItemGroupTrait]...';


GO
CREATE TABLE [dbo].[ItemGroupTrait] (
    [traitID]     INT            NOT NULL,
    [itemGroupID] INT            NOT NULL,
    [uomID]       INT            NULL,
    [traitValue]  NVARCHAR (255) NULL,
    CONSTRAINT [ItemGroupTrait_PK] PRIMARY KEY CLUSTERED ([traitID] ASC, [ItemGroupID] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating Country_PhysicalAddress_FK1...';


GO
ALTER TABLE [dbo].[PhysicalAddress] WITH NOCHECK
    ADD CONSTRAINT [Country_PhysicalAddress_FK1] FOREIGN KEY ([countryCode]) REFERENCES [dbo].[Country] ([countryCode]);


GO
PRINT N'Creating Country_PostalCode_FK1...';


GO
ALTER TABLE [dbo].[PostalCode] WITH NOCHECK
    ADD CONSTRAINT [Country_PostalCode_FK1] FOREIGN KEY ([countryCode]) REFERENCES [dbo].[Country] ([countryCode]);


GO
PRINT N'Creating Country_Territory_FK1...';


GO
ALTER TABLE [dbo].[Territory] WITH NOCHECK
    ADD CONSTRAINT [Country_Territory_FK1] FOREIGN KEY ([countryCode]) REFERENCES [dbo].[Country] ([countryCode]);


GO
PRINT N'Creating CurrencyType_ItemPrice_FK1...';


GO
ALTER TABLE [dbo].[ItemPrice] WITH NOCHECK
    ADD CONSTRAINT [CurrencyType_ItemPrice_FK1] FOREIGN KEY ([currencyTypeID]) REFERENCES [dbo].[CurrencyType] ([currencyTypeID]);


GO
PRINT N'Creating UOM_ItemPrice_FK1...';


GO
ALTER TABLE [dbo].[ItemPrice] WITH NOCHECK
    ADD CONSTRAINT [UOM_ItemPrice_FK1] FOREIGN KEY ([uomID]) REFERENCES [dbo].[UOM] ([uomID]);


GO
PRINT N'Creating ItemPriceType_ItemPrice_FK1...';


GO
ALTER TABLE [dbo].[ItemPrice] WITH NOCHECK
    ADD CONSTRAINT [ItemPriceType_ItemPrice_FK1] FOREIGN KEY ([itemPriceTypeID]) REFERENCES [dbo].[ItemPriceType] ([itemPriceTypeID]);


GO
PRINT N'Creating UOM_ItemTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemTrait] WITH NOCHECK
    ADD CONSTRAINT [UOM_ItemTrait_FK1] FOREIGN KEY ([uomID]) REFERENCES [dbo].[UOM] ([uomID]);


GO
PRINT N'Creating ItemType_Item_FK1...';


GO
ALTER TABLE [dbo].[Item] WITH NOCHECK
    ADD CONSTRAINT [ItemType_Item_FK1] FOREIGN KEY ([itemTypeID]) REFERENCES [dbo].[ItemType] ([itemTypeID]);


GO
PRINT N'Creating UOM_LocaleTrait_FK1...';


GO
ALTER TABLE [dbo].[LocaleTrait] WITH NOCHECK
    ADD CONSTRAINT [UOM_LocaleTrait_FK1] FOREIGN KEY ([uomID]) REFERENCES [dbo].[UOM] ([uomID]);


GO
PRINT N'Creating LocaleType_Locale_FK1...';


GO
ALTER TABLE [dbo].[Locale] WITH NOCHECK
    ADD CONSTRAINT [LocaleType_Locale_FK1] FOREIGN KEY ([localeTypeID]) REFERENCES [dbo].[LocaleType] ([localeTypeID]);


GO
PRINT N'Creating Organization_Locale_FK1...';


GO
ALTER TABLE [dbo].[Locale] WITH NOCHECK
    ADD CONSTRAINT [Organization_Locale_FK1] FOREIGN KEY ([ownerOrgPartyID]) REFERENCES [dbo].[Organization] ([orgPartyID]);


GO
PRINT N'Creating Party_Organization_FK1...';


GO
ALTER TABLE [dbo].[Organization] WITH NOCHECK
    ADD CONSTRAINT [Party_Organization_FK1] FOREIGN KEY ([orgPartyID]) REFERENCES [dbo].[Party] ([partyID]);


GO
PRINT N'Creating Organization_Organization_FK1...';


GO
ALTER TABLE [dbo].[Organization] WITH NOCHECK
    ADD CONSTRAINT [Organization_Organization_FK1] FOREIGN KEY ([parentOrgPartyID]) REFERENCES [dbo].[Organization] ([orgPartyID]);


GO
PRINT N'Creating OrganizationType_Organization_FK1...';


GO
ALTER TABLE [dbo].[Organization] WITH NOCHECK
    ADD CONSTRAINT [OrganizationType_Organization_FK1] FOREIGN KEY ([orgTypeID]) REFERENCES [dbo].[OrganizationType] ([orgTypeID]);


GO
PRINT N'Creating Organization_OrganizationName_FK1...';


GO
ALTER TABLE [dbo].[OrganizationName] WITH NOCHECK
    ADD CONSTRAINT [Organization_OrganizationName_FK1] FOREIGN KEY ([orgPartyID]) REFERENCES [dbo].[Organization] ([orgPartyID]);


GO
PRINT N'Creating PartyType_Party_FK1...';


GO
ALTER TABLE [dbo].[Party] WITH NOCHECK
    ADD CONSTRAINT [PartyType_Party_FK1] FOREIGN KEY ([partyTypeID]) REFERENCES [dbo].[PartyType] ([partyTypeID]);


GO
PRINT N'Creating PostalCode_PhysicalAddress_FK1...';


GO
ALTER TABLE [dbo].[PhysicalAddress] WITH NOCHECK
    ADD CONSTRAINT [PostalCode_PhysicalAddress_FK1] FOREIGN KEY ([postalCode], [countryCode]) REFERENCES [dbo].[PostalCode] ([postalCode], [countryCode]);


GO
PRINT N'Creating County_PostalCode_FK1...';


GO
ALTER TABLE [dbo].[PostalCode] WITH NOCHECK
    ADD CONSTRAINT [County_PostalCode_FK1] FOREIGN KEY ([countyCode]) REFERENCES [dbo].[County] ([countyCode]);


GO
PRINT N'Creating Trait_ItemTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemTrait] WITH NOCHECK
    ADD CONSTRAINT [Trait_ItemTrait_FK1] FOREIGN KEY ([traitID]) REFERENCES [dbo].[Trait] ([traitID]);


GO
PRINT N'Creating Trait_LocaleTrait_FK1...';


GO
ALTER TABLE [dbo].[LocaleTrait] WITH NOCHECK
    ADD CONSTRAINT [Trait_LocaleTrait_FK1] FOREIGN KEY ([traitID]) REFERENCES [dbo].[Trait] ([traitID]);


GO
PRINT N'Creating TraitGroup_Trait_FK1...';


GO
ALTER TABLE [dbo].[Trait] WITH NOCHECK
    ADD CONSTRAINT [TraitGroup_Trait_FK1] FOREIGN KEY ([traitGroupID]) REFERENCES [dbo].[TraitGroup] ([traitGroupID]);


GO
PRINT N'***Hack #9***  Skipping: Creating Item_PLUMap_ItemID_FK...';


--GO
--ALTER TABLE [app].[PLUMap] WITH NOCHECK
--    ADD CONSTRAINT [Item_PLUMap_ItemID_FK] FOREIGN KEY ([itemID]) REFERENCES [dbo].[Item] ([itemID]);


GO
PRINT N'Creating UOM_HierarchyClassTrait_FK1...';


GO
ALTER TABLE [dbo].[HierarchyClassTrait] WITH NOCHECK
    ADD CONSTRAINT [UOM_HierarchyClassTrait_FK1] FOREIGN KEY ([uomID]) REFERENCES [dbo].[UOM] ([uomID]);


GO
PRINT N'Creating Trait_HierarchyClassTrait_FK1...';


GO
ALTER TABLE [dbo].[HierarchyClassTrait] WITH NOCHECK
    ADD CONSTRAINT [Trait_HierarchyClassTrait_FK1] FOREIGN KEY ([traitID]) REFERENCES [dbo].[Trait] ([traitID]);


GO
PRINT N'Creating HierarchyClass_HierarchyClassTrait_FK1...';


GO
ALTER TABLE [dbo].[HierarchyClassTrait] WITH NOCHECK
    ADD CONSTRAINT [HierarchyClass_HierarchyClassTrait_FK1] FOREIGN KEY ([HierarchyClassID]) REFERENCES [dbo].[HierarchyClass] ([hierarchyClassID]);


GO
PRINT N'Creating UOM_ItemGroupTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemGroupTrait] WITH NOCHECK
    ADD CONSTRAINT [UOM_ItemGroupTrait_FK1] FOREIGN KEY ([uomID]) REFERENCES [dbo].[UOM] ([uomID]);


GO
PRINT N'Creating Trait_ItemGroupTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemGroupTrait] WITH NOCHECK
    ADD CONSTRAINT [Trait_ItemGroupTrait_FK1] FOREIGN KEY ([traitID]) REFERENCES [dbo].[Trait] ([traitID]);


GO
PRINT N'Creating ItemGroup_ItemGroupTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemGroupTrait] WITH NOCHECK
    ADD CONSTRAINT [ItemGroup_ItemGroupTrait_FK1] FOREIGN KEY ([ItemGroupID]) REFERENCES [dbo].[ItemGroup] ([itemGroupID]);


--GO
PRINT N'***Hack #10 - 14 ***  SKIPPING THE Refresh of Views like: Refreshing [app].[vItemBase]...';


--GO
--EXECUTE sp_refreshsqlmodule N'[app].[vItemBase]';


--GO
--PRINT N'Refreshing [app].[vItemImport]...';


--GO
--EXECUTE sp_refreshsqlmodule N'[app].[vItemImport]';


--GO
--PRINT N'Refreshing [app].[vItemsAndTraits]...';


--GO
--EXECUTE sp_refreshsqlmodule N'[app].[vItemsAndTraits]';


--GO
--PRINT N'Refreshing [app].[UpdateItemListByTrait]...';


--GO
--EXECUTE sp_refreshsqlmodule N'[app].[UpdateItemListByTrait]';


--GO
--PRINT N'Refreshing [app].[ItemImport]...';


--GO
--EXECUTE sp_refreshsqlmodule N'[app].[ItemImport]';


GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[PhysicalAddress] WITH CHECK CHECK CONSTRAINT [Country_PhysicalAddress_FK1];

ALTER TABLE [dbo].[PostalCode] WITH CHECK CHECK CONSTRAINT [Country_PostalCode_FK1];

ALTER TABLE [dbo].[Territory] WITH CHECK CHECK CONSTRAINT [Country_Territory_FK1];

ALTER TABLE [dbo].[ItemPrice] WITH CHECK CHECK CONSTRAINT [CurrencyType_ItemPrice_FK1];

ALTER TABLE [dbo].[ItemPrice] WITH CHECK CHECK CONSTRAINT [UOM_ItemPrice_FK1];

ALTER TABLE [dbo].[ItemPrice] WITH CHECK CHECK CONSTRAINT [ItemPriceType_ItemPrice_FK1];

ALTER TABLE [dbo].[ItemTrait] WITH CHECK CHECK CONSTRAINT [UOM_ItemTrait_FK1];

ALTER TABLE [dbo].[Item] WITH CHECK CHECK CONSTRAINT [ItemType_Item_FK1];

ALTER TABLE [dbo].[LocaleTrait] WITH CHECK CHECK CONSTRAINT [UOM_LocaleTrait_FK1];

ALTER TABLE [dbo].[Locale] WITH CHECK CHECK CONSTRAINT [LocaleType_Locale_FK1];

ALTER TABLE [dbo].[Locale] WITH CHECK CHECK CONSTRAINT [Organization_Locale_FK1];

ALTER TABLE [dbo].[Organization] WITH CHECK CHECK CONSTRAINT [Party_Organization_FK1];

ALTER TABLE [dbo].[Organization] WITH CHECK CHECK CONSTRAINT [Organization_Organization_FK1];

ALTER TABLE [dbo].[Organization] WITH CHECK CHECK CONSTRAINT [OrganizationType_Organization_FK1];

ALTER TABLE [dbo].[OrganizationName] WITH CHECK CHECK CONSTRAINT [Organization_OrganizationName_FK1];

ALTER TABLE [dbo].[Party] WITH CHECK CHECK CONSTRAINT [PartyType_Party_FK1];

ALTER TABLE [dbo].[PhysicalAddress] WITH CHECK CHECK CONSTRAINT [PostalCode_PhysicalAddress_FK1];

ALTER TABLE [dbo].[PostalCode] WITH CHECK CHECK CONSTRAINT [County_PostalCode_FK1];

ALTER TABLE [dbo].[ItemTrait] WITH CHECK CHECK CONSTRAINT [Trait_ItemTrait_FK1];

ALTER TABLE [dbo].[LocaleTrait] WITH CHECK CHECK CONSTRAINT [Trait_LocaleTrait_FK1];

ALTER TABLE [dbo].[Trait] WITH CHECK CHECK CONSTRAINT [TraitGroup_Trait_FK1];

ALTER TABLE [app].[PLUMap] WITH CHECK CHECK CONSTRAINT [Item_PLUMap_ItemID_FK];

ALTER TABLE [dbo].[HierarchyClassTrait] WITH CHECK CHECK CONSTRAINT [UOM_HierarchyClassTrait_FK1];

ALTER TABLE [dbo].[HierarchyClassTrait] WITH CHECK CHECK CONSTRAINT [Trait_HierarchyClassTrait_FK1];

ALTER TABLE [dbo].[HierarchyClassTrait] WITH CHECK CHECK CONSTRAINT [HierarchyClass_HierarchyClassTrait_FK1];

ALTER TABLE [dbo].[ItemGroupTrait] WITH CHECK CHECK CONSTRAINT [UOM_ItemGroupTrait_FK1];

ALTER TABLE [dbo].[ItemGroupTrait] WITH CHECK CHECK CONSTRAINT [Trait_ItemGroupTrait_FK1];

ALTER TABLE [dbo].[ItemGroupTrait] WITH CHECK CHECK CONSTRAINT [ItemGroup_ItemGroupTrait_FK1];


GO
PRINT N'Update complete.';


GO
USE [$(DatabaseName)];


GO
--PRINT N'Dropping [dbo].[ItemTrait].[IX_ItemTrait_ItemID_INC_TraitIDAndValue]...';
--GO
--DROP INDEX [IX_ItemTrait_ItemID_INC_TraitIDAndValue]
--    ON [dbo].[ItemTrait];
--GO

PRINT N'Dropping Locale_ItemTrait_FK1...';
GO
ALTER TABLE [dbo].[ItemTrait] DROP CONSTRAINT [Locale_ItemTrait_FK1];
GO

PRINT N'Dropping UOM_ItemTrait_FK1...';
GO
ALTER TABLE [dbo].[ItemTrait] DROP CONSTRAINT [UOM_ItemTrait_FK1];
GO

PRINT N'Dropping Item_ItemTrait_FK1...';
GO
ALTER TABLE [dbo].[ItemTrait] DROP CONSTRAINT [Item_ItemTrait_FK1];
GO

PRINT N'Dropping Trait_ItemTrait_FK1...';
GO
ALTER TABLE [dbo].[ItemTrait] DROP CONSTRAINT [Trait_ItemTrait_FK1];
GO
/*
The column localeID on table [dbo].[ItemTrait] must be changed from NULL to NOT NULL. If the table contains data, the ALTER script may not work. To avoid this issue, you must add values to this column for all rows or mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
GO
PRINT N'Starting rebuilding table [dbo].[ItemTrait]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_ItemTrait] (
    [traitID]    INT            NOT NULL,
    [itemID]     INT            NOT NULL,
    [uomID]      NVARCHAR (5)   NULL,
    [traitValue] NVARCHAR (255) NULL,
    [localeID]   INT            NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_ItemTrait_PK] PRIMARY KEY CLUSTERED ([traitID] ASC, [itemID] ASC, [localeID] ASC)
);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[ItemTrait])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_ItemTrait] ([traitID], [itemID], [localeID], [uomID], [traitValue])
        SELECT   [traitID],
                 [itemID],
                 1 as [localeID],
                 [uomID],
                 [traitValue]
        FROM     [dbo].[ItemTrait]
        ORDER BY [traitID] ASC, [itemID] ASC, [localeID] ASC;
    END

DROP TABLE [dbo].[ItemTrait];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_ItemTrait]', N'ItemTrait';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_ItemTrait_PK]', N'ItemTrait_PK', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating Locale_ItemTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemTrait] WITH NOCHECK
    ADD CONSTRAINT [Locale_ItemTrait_FK1] FOREIGN KEY ([localeID]) REFERENCES [dbo].[Locale] ([localeID]);


GO
PRINT N'Creating Item_ItemTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemTrait] WITH NOCHECK
    ADD CONSTRAINT [Item_ItemTrait_FK1] FOREIGN KEY ([itemID]) REFERENCES [dbo].[Item] ([itemID]);


GO
PRINT N'Creating Trait_ItemTrait_FK1...';


GO
ALTER TABLE [dbo].[ItemTrait] WITH NOCHECK
    ADD CONSTRAINT [Trait_ItemTrait_FK1] FOREIGN KEY ([traitID]) REFERENCES [dbo].[Trait] ([traitID]);


GO
GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[ItemTrait] WITH CHECK CHECK CONSTRAINT [Locale_ItemTrait_FK1];

ALTER TABLE [dbo].[ItemTrait] WITH CHECK CHECK CONSTRAINT [Item_ItemTrait_FK1];

ALTER TABLE [dbo].[ItemTrait] WITH CHECK CHECK CONSTRAINT [Trait_ItemTrait_FK1];


GO
PRINT N'Update complete.';


GO

-- end second script

/*
Deployment script for IconTestStage2

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "IconTestStage2"
:setvar DefaultFilePrefix "IconTestStage2"
:setvar DefaultDataPath "E:\SQL_DATA\SQLSHARED2012D\"
:setvar DefaultLogPath "E:\SQL_LOGS\SQLSHARED2012D\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Dropping [dbo].[ScanCode].[ScanCode_scanCode]...';


GO
DROP INDEX [ScanCode_scanCode]
    ON [dbo].[ScanCode];


GO
PRINT N'Dropping DF_InsertDate...';


GO
ALTER TABLE [app].[EventQueue] DROP CONSTRAINT [DF_InsertDate];


GO
PRINT N'Dropping FK_EventQueue_EventType...';


GO
ALTER TABLE [app].[EventQueue] DROP CONSTRAINT [FK_EventQueue_EventType];


GO
PRINT N'Dropping [app].[UpdateItemListByTrait]...';


GO
DROP PROCEDURE [app].[UpdateItemListByTrait];


GO
PRINT N'Dropping [app].[Init.PopData.SetupOrganization]...';


GO
DROP PROCEDURE [app].[Init.PopData.SetupOrganization];


GO
PRINT N'Dropping [app].[Init.PopData.SetupParty]...';


GO
DROP PROCEDURE [app].[Init.PopData.SetupParty];


GO
PRINT N'Dropping [app].[ItemListByTraitType]...';


GO
DROP TYPE [app].[ItemListByTraitType];


GO
PRINT N'Creating [app].[ItemListByTraitType]...';


GO
CREATE TYPE [app].[ItemListByTraitType] AS TABLE (
    [itemID]     INT            NULL,
    [traitID]    INT            NULL,
    [traitDesc]  NVARCHAR (255) NULL,
    [traitValue] NVARCHAR (255) NULL);


GO
PRINT N'Creating [app].[EventQueueEntriesType]...';


GO
CREATE TYPE [app].[EventQueueEntriesType] AS TABLE (
    [EventMessage]     NVARCHAR (255) NULL,
    [EventReferenceId] INT            NULL);


GO
PRINT N'Creating [app].[RegionAbbrType]...';


GO
CREATE TYPE [app].[RegionAbbrType] AS TABLE (
    [RegionAbbr] CHAR (2) NULL);


GO
PRINT N'Creating [app].[TaxHierarchyClassUpdateType]...';


GO
CREATE TYPE [app].[TaxHierarchyClassUpdateType] AS TABLE (
    [HierarchyClassID]   NVARCHAR (7)   NULL,
    [HierarchyClassName] NVARCHAR (255) NULL);


GO
PRINT N'Creating [app].[UpdatedItemIDsType]...';


GO
CREATE TYPE [app].[UpdatedItemIDsType] AS TABLE (
    [itemID] INT NULL);


GO
PRINT N'Creating [app].[IRMAPush]...';


GO
CREATE TABLE [app].[IRMAPush] (
    [IRMAPushID]         INT            IDENTITY (1, 1) NOT NULL,
    [RegionCode]         VARCHAR (4)    NOT NULL,
    [BusinessUnit_ID]    INT            NOT NULL,
    [Identifier]         VARCHAR (13)   NOT NULL,
    [ChangeType]         VARCHAR (30)   NOT NULL,
    [InsertDate]         DATETIME       NOT NULL,
    [RetailSize]         DECIMAL (9, 4) NULL,
    [RetailPackageUom]   VARCHAR (5)    NULL,
    [TMDiscountEligible] BIT            NULL,
    [Case_Discount]      BIT            NULL,
    [AgeCode]            INT            NULL,
    [Recall_Flag]        BIT            NULL,
    [Restricted_Hours]   BIT            NULL,
    [Sold_By_Weight]     BIT            NULL,
    [ScaleForcedTare]    BIT            NULL,
    [Quantity_Required]  BIT            NULL,
    [Price_Required]     BIT            NULL,
    [QtyProhibit]        BIT            NULL,
    [VisualVerify]       BIT            NULL,
    [RestrictSale]       BIT            NULL,
    [Price]              MONEY          NULL,
    [RetailUom]          VARCHAR (5)    NULL,
    [Multiple]           INT            NULL,
    [SaleMultiple]       INT            NULL,
    [Sale_Price]         MONEY          NULL,
    [Sale_Start_Date]    SMALLDATETIME  NULL,
    [Sale_End_Date]      SMALLDATETIME  NULL,
    [InProcessBy]        VARCHAR (30)   NULL,
    [InUdmDate]          DATETIME2 (7)  NULL,
    [EsbReadyDate]       DATETIME2 (7)  NULL,
    [UdmFailedDate]      DATETIME2 (7)  NULL,
    [EsbReadyFailedDate] DATETIME2 (7)  NULL,
    CONSTRAINT [PK_IrmaPush_IrmaPushID] PRIMARY KEY CLUSTERED ([IRMAPushID] ASC) WITH (FILLFACTOR = 80),
    CONSTRAINT [UQ_IrmaPush_keys] UNIQUE NONCLUSTERED ([BusinessUnit_ID] ASC, [Identifier] ASC, [ChangeType] ASC, [InsertDate] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageAction]...';


GO
CREATE TABLE [app].[MessageAction] (
    [MessageActionId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageActionName] NVARCHAR (255) NOT NULL,
    CONSTRAINT [PK_MessageActionId] PRIMARY KEY CLUSTERED ([MessageActionId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageException]...';


GO
CREATE TABLE [app].[MessageException] (
    [MessageExceptionId] INT             IDENTITY (1, 1) NOT NULL,
    [MessageHistoryId]   INT             NOT NULL,
    [ResponseCode]       NVARCHAR (255)  NULL,
    [Severity]           NVARCHAR (255)  NULL,
    [Code]               NVARCHAR (255)  NULL,
    [Description]        NVARCHAR (4000) NULL,
    [AdditionalData]     NVARCHAR (255)  NULL,
    [InsertDate]         DATETIME2 (7)   NOT NULL,
    CONSTRAINT [PK_MessageExceptionId] PRIMARY KEY CLUSTERED ([MessageExceptionId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageHistory]...';


GO
CREATE TABLE [app].[MessageHistory] (
    [MessageHistoryId] INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]    INT            NOT NULL,
    [MessageStatusId]  INT            NOT NULL,
    [Note]             NVARCHAR (255) NULL,
    [Message]          XML            NOT NULL,
    [InsertDate]       DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageHistoryId] PRIMARY KEY CLUSTERED ([MessageHistoryId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueHierarchy]...';


GO
CREATE TABLE [app].[MessageQueueHierarchy] (
    [MessageQueueId]         INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]          INT            NOT NULL,
    [MessageStatusId]        INT            NOT NULL,
    [MessageHistoryId]       INT            NULL,
    [MessageActionId]        INT            NOT NULL,
    [HierarchyId]            INT            NOT NULL,
    [HierarchyName]          NVARCHAR (255) NOT NULL,
    [HierarchyLevelName]     NVARCHAR (255) NOT NULL,
    [ItemsAttached]          BIT            NOT NULL,
    [HierarchyClassId]       INT            NOT NULL,
    [HierarchyClassName]     NVARCHAR (255) NOT NULL,
    [HierarchyLevel]         INT            NOT NULL,
    [HierarchyParentClassId] INT            NULL,
    [InsertDate]             DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueueHierarchy] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueItemLocale]...';


GO
CREATE TABLE [app].[MessageQueueItemLocale] (
    [MessageQueueId]     INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]      INT            NOT NULL,
    [MessageStatusId]    INT            NOT NULL,
    [MessageHistoryId]   INT            NULL,
    [MessageActionId]    INT            NOT NULL,
    [IRMAPushID]         INT            NOT NULL,
    [RegionCode]         VARCHAR (4)    NOT NULL,
    [BusinessUnit_ID]    INT            NOT NULL,
    [ItemId]             INT            NOT NULL,
    [ItemTypeCode]       NVARCHAR (3)   NOT NULL,
    [ItemTypeDesc]       NVARCHAR (255) NOT NULL,
    [LocaleId]           INT            NOT NULL,
    [LocaleName]         VARCHAR (255)  NOT NULL,
    [ScanCodeId]         INT            NOT NULL,
    [ScanCode]           VARCHAR (13)   NOT NULL,
    [ScanCodeTypeId]     INT            NOT NULL,
    [ScanCodeTypeDesc]   NVARCHAR (255) NOT NULL,
    [ChangeType]         VARCHAR (32)   NOT NULL,
    [LockedForSale]      BIT            NOT NULL,
    [Recall]             BIT            NOT NULL,
    [RetailSize]         DECIMAL (9, 4) NULL,
    [RetailPackageUom]   VARCHAR (5)    NULL,
    [TMDiscountEligible] BIT            NULL,
    [Case_Discount]      BIT            NULL,
    [AgeCode]            INT            NULL,
    [Restricted_Hours]   BIT            NULL,
    [Sold_By_Weight]     BIT            NULL,
    [ScaleForcedTare]    BIT            NULL,
    [Quantity_Required]  BIT            NULL,
    [Price_Required]     BIT            NULL,
    [QtyProhibit]        BIT            NULL,
    [VisualVerify]       BIT            NULL,
    [InsertDate]         DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueueItemLocale] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueLocale]...';


GO
CREATE TABLE [app].[MessageQueueLocale] (
    [MessageQueueId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]    INT            NOT NULL,
    [MessageStatusId]  INT            NOT NULL,
    [MessageHistoryId] INT            NULL,
    [LocaleId]         INT            NOT NULL,
    [OwnerOrgPartyId]  INT            NOT NULL,
    [LocaleName]       NVARCHAR (255) NOT NULL,
    [LocaleOpenDate]   DATE           NULL,
    [LocaleCloseDate]  DATE           NULL,
    [LocaleTypeId]     INT            NOT NULL,
    [ParentLocaleId]   INT            NULL,
    [BusinessUnitId]   NVARCHAR (255) NOT NULL,
    [InsertDate]       DATETIME2 (7)  NOT NULL,
    [CountryCode]      NVARCHAR (3)   NULL,
    [TerritoryCode]    NVARCHAR (3)   NULL,
    [CityCode]         INT            NULL,
    [PostalCode]       INT            NULL,
    [Latitude]         NVARCHAR (255) NULL,
    [Longitude]        NVARCHAR (255) NULL,
    [AddressLine1]     NVARCHAR (255) NULL,
    [AddressLine2]     NVARCHAR (255) NULL,
    [AddressLine3]     NVARCHAR (255) NULL,
    [TimezoneCode]     INT            NULL,
    CONSTRAINT [PK_app.MessageQueueLocale] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueuePrice]...';


GO
CREATE TABLE [app].[MessageQueuePrice] (
    [MessageQueueId]        INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]         INT            NOT NULL,
    [MessageStatusId]       INT            NOT NULL,
    [MessageHistoryId]      INT            NULL,
    [IRMAPushID]            INT            NOT NULL,
    [RegionCode]            NVARCHAR (4)   NOT NULL,
    [BusinessUnit_ID]       INT            NOT NULL,
    [ItemId]                INT            NOT NULL,
    [ItemTypeCode]          NVARCHAR (3)   NOT NULL,
    [ItemTypeDesc]          NVARCHAR (255) NOT NULL,
    [LocaleId]              INT            NOT NULL,
    [LocaleName]            NVARCHAR (255) NOT NULL,
    [ScanCodeId]            INT            NOT NULL,
    [ScanCode]              NVARCHAR (13)  NOT NULL,
    [ScanCodeTypeId]        INT            NOT NULL,
    [ScanCodeTypeDesc]      NVARCHAR (255) NOT NULL,
    [ChangeType]            NVARCHAR (32)  NOT NULL,
    [UomCode]               NVARCHAR (3)   NOT NULL,
    [UomName]               NVARCHAR (100) NULL,
    [CurrencyCode]          NVARCHAR (3)   NOT NULL,
    [Price]                 MONEY          NULL,
    [Multiple]              INT            NULL,
    [SalePrice]             MONEY          NULL,
    [SaleMultiple]          INT            NULL,
    [SaleStartDate]         DATETIME2 (7)  NULL,
    [SaleEndDate]           DATETIME2 (7)  NULL,
    [PreviousSalePrice]     MONEY          NULL,
    [PreviousSaleMultiple]  INT            NULL,
    [PreviousSaleStartDate] DATETIME2 (7)  NULL,
    [PreviousSaleEndDate]   DATETIME2 (7)  NULL,
    [InsertDate]            DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueuePrice] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageQueueProduct]...';


GO
CREATE TABLE [app].[MessageQueueProduct] (
    [MessageQueueId]         INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeId]          INT            NOT NULL,
    [MessageStatusId]        INT            NOT NULL,
    [MessageHistoryId]       INT            NULL,
    [ItemId]                 INT            NOT NULL,
    [LocaleId]               INT            NOT NULL,
    [ItemTypeCode]           NVARCHAR (3)   NOT NULL,
    [ItemTypeDesc]           NVARCHAR (255) NOT NULL,
    [ScanCodeId]             INT            NOT NULL,
    [ScanCode]               NVARCHAR (13)  NOT NULL,
    [ScanCodeTypeId]         INT            NOT NULL,
    [ScanCodeTypeDesc]       NVARCHAR (255) NOT NULL,
    [ProductDescription]     NVARCHAR (255) NOT NULL,
    [PosDescription]         NVARCHAR (255) NOT NULL,
    [PackageUnit]            NVARCHAR (255) NOT NULL,
    [FoodStampEligible]      NVARCHAR (255) NOT NULL,
    [PosScaleTare]           NVARCHAR (255) NOT NULL,
    [DepartmentSale]         NVARCHAR (255) NOT NULL,
    [BrandId]                INT            NOT NULL,
    [BrandName]              NVARCHAR (255) NOT NULL,
    [BrandLevel]             INT            NOT NULL,
    [BrandParentId]          INT            NULL,
    [BrowsingClassId]        INT            NULL,
    [BrowsingClassName]      NVARCHAR (255) NULL,
    [BrowsingLevel]          INT            NULL,
    [BrowsingParentId]       INT            NULL,
    [MerchandisingClassId]   INT            NOT NULL,
    [MerchandisingClassName] NVARCHAR (255) NOT NULL,
    [MerchandisingLevel]     INT            NOT NULL,
    [MerchandisingParentId]  INT            NULL,
    [TaxClassId]             INT            NOT NULL,
    [TaxClassName]           NVARCHAR (255) NOT NULL,
    [TaxLevel]               INT            NOT NULL,
    [TaxParentId]            INT            NULL,
    [FinancialClassId]       INT            NOT NULL,
    [FinancialClassName]     NVARCHAR (255) NOT NULL,
    [FinancialLevel]         INT            NOT NULL,
    [FinancialParentId]      INT            NULL,
    [InsertDate]             DATETIME2 (7)  NOT NULL,
    CONSTRAINT [PK_MessageQueueProduct] PRIMARY KEY CLUSTERED ([MessageQueueId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageResponse]...';


GO
CREATE TABLE [app].[MessageResponse] (
    [MessageResponseId] INT           IDENTITY (1, 1) NOT NULL,
    [MessageHistoryId]  INT           NOT NULL,
    [ResponseText]      XML           NOT NULL,
    [Success]           BIT           NOT NULL,
    [InsertDate]        DATETIME2 (7) NOT NULL,
    CONSTRAINT [PK_MessageResponse] PRIMARY KEY CLUSTERED ([MessageResponseId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageStatus]...';


GO
CREATE TABLE [app].[MessageStatus] (
    [MessageStatusId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageStatusName] NVARCHAR (255) NOT NULL,
    CONSTRAINT [PK_MessageStatusId] PRIMARY KEY CLUSTERED ([MessageStatusId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [app].[MessageType]...';


GO
CREATE TABLE [app].[MessageType] (
    [MessageTypeId]   INT            IDENTITY (1, 1) NOT NULL,
    [MessageTypeName] NVARCHAR (255) NOT NULL,
    CONSTRAINT [PK_MessageTypeId] PRIMARY KEY CLUSTERED ([MessageTypeId] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [dbo].[ItemHierarchyClass].[ItemHierarchyClass_itemID]...';


GO
CREATE NONCLUSTERED INDEX [ItemHierarchyClass_itemID]
    ON [dbo].[ItemHierarchyClass]([itemID] ASC)
    INCLUDE([hierarchyClassID]) WITH (FILLFACTOR = 80);


GO
PRINT N'Creating DF_IRMAPush_InsertDate...';


GO
ALTER TABLE [app].[IRMAPush]
    ADD CONSTRAINT [DF_IRMAPush_InsertDate] DEFAULT (getdate()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageException_InsertDate...';


GO
ALTER TABLE [app].[MessageException]
    ADD CONSTRAINT [DF_MessageException_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageHistory_InsertDate...';


GO
ALTER TABLE [app].[MessageHistory]
    ADD CONSTRAINT [DF_MessageHistory_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueueHierarchy_InsertDate...';


GO
ALTER TABLE [app].[MessageQueueHierarchy]
    ADD CONSTRAINT [DF_MessageQueueHierarchy_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueueItemLocale_LockedForSale...';


GO
ALTER TABLE [app].[MessageQueueItemLocale]
    ADD CONSTRAINT [DF_MessageQueueItemLocale_LockedForSale] DEFAULT ((0)) FOR [LockedForSale];


GO
PRINT N'Creating DF_MessageQueueItemLocale_Recall...';


GO
ALTER TABLE [app].[MessageQueueItemLocale]
    ADD CONSTRAINT [DF_MessageQueueItemLocale_Recall] DEFAULT ((0)) FOR [Recall];


GO
PRINT N'Creating DF_MessageQueueItemLocale_InsertDate...';


GO
ALTER TABLE [app].[MessageQueueItemLocale]
    ADD CONSTRAINT [DF_MessageQueueItemLocale_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueuePrice_InsertDate...';


GO
ALTER TABLE [app].[MessageQueuePrice]
    ADD CONSTRAINT [DF_MessageQueuePrice_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating DF_MessageQueueProduct_InsertDate...';


GO
ALTER TABLE [app].[MessageQueueProduct]
    ADD CONSTRAINT [DF_MessageQueueProduct_InsertDate] DEFAULT (sysdatetime()) FOR [InsertDate];


GO
PRINT N'Creating FK_MessageException_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageException] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageException_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageHistory_MessageStatus...';


GO
ALTER TABLE [app].[MessageHistory] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageHistory_MessageStatus] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageHistory_MessageType...';


GO
ALTER TABLE [app].[MessageHistory] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageHistory_MessageType] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageActionId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageActionId] FOREIGN KEY ([MessageActionId]) REFERENCES [app].[MessageAction] ([MessageActionId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueueHierarchy_MessageTypeId...';


GO
ALTER TABLE [app].[MessageQueueHierarchy] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueHierarchy_MessageTypeId] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageTypeId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageTypeId] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_IRMAPushID...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_IRMAPushID] FOREIGN KEY ([IRMAPushID]) REFERENCES [app].[IRMAPush] ([IRMAPushID]);


GO
PRINT N'Creating FK_MessageQueueItemLocale_MessageActionId...';


GO
ALTER TABLE [app].[MessageQueueItemLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueItemLocale_MessageActionId] FOREIGN KEY ([MessageActionId]) REFERENCES [app].[MessageAction] ([MessageActionId]);


GO
PRINT N'Creating FK_app.MessageQueueLocale_MessageType...';


GO
ALTER TABLE [app].[MessageQueueLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_app.MessageQueueLocale_MessageType] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_app.MessageQueueLocale_MessageStatus...';


GO
ALTER TABLE [app].[MessageQueueLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_app.MessageQueueLocale_MessageStatus] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_app.MessageQueueLocale_MessageHistory...';


GO
ALTER TABLE [app].[MessageQueueLocale] WITH NOCHECK
    ADD CONSTRAINT [FK_app.MessageQueueLocale_MessageHistory] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueuePrice_MessageTypeID...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_MessageTypeID] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueuePrice_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueuePrice_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Creating FK_MessageQueuePrice_IRMAPushID...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_IRMAPushID] FOREIGN KEY ([IRMAPushID]) REFERENCES [app].[IRMAPush] ([IRMAPushID]);


GO
PRINT N'Creating FK_MessageQueuePrice_UomCode...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_UomCode] FOREIGN KEY ([UomCode]) REFERENCES [dbo].[UOM] ([uomCode]);


GO
PRINT N'Creating FK_MessageQueuePrice_CurrencyCode...';


GO
ALTER TABLE [app].[MessageQueuePrice] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueuePrice_CurrencyCode] FOREIGN KEY ([CurrencyCode]) REFERENCES [dbo].[CurrencyType] ([currencyTypeCode]);


GO
PRINT N'Creating FK_MessageQueueProduct_MessageStatusId...';


GO
ALTER TABLE [app].[MessageQueueProduct] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueProduct_MessageStatusId] FOREIGN KEY ([MessageStatusId]) REFERENCES [app].[MessageStatus] ([MessageStatusId]);


GO
PRINT N'Creating FK_MessageQueueProduct_MessageTypeId...';


GO
ALTER TABLE [app].[MessageQueueProduct] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueProduct_MessageTypeId] FOREIGN KEY ([MessageTypeId]) REFERENCES [app].[MessageType] ([MessageTypeId]);


GO
PRINT N'Creating FK_MessageQueueProduct_MessageHistoryId...';


GO
ALTER TABLE [app].[MessageQueueProduct] WITH NOCHECK
    ADD CONSTRAINT [FK_MessageQueueProduct_MessageHistoryId] FOREIGN KEY ([MessageHistoryId]) REFERENCES [app].[MessageHistory] ([MessageHistoryId]);


GO
PRINT N'Altering [app].[vItemBase]...';


GO
/*
Index Help:
Missing Index Details - sqlshared2-dev\sqlshared2012d.iCon (WFM\Tom.Lux (58))
The Query Processor estimates that implementing the following index could improve the query cost by 75.1693%.

USE [iCon]
GO
CREATE NONCLUSTERED INDEX [???]
ON [dbo].[ItemTrait] ([itemID])
INCLUDE ([traitID],[traitValue])
GO
*/


ALTER VIEW [app].[vItemBase]
	AS
SELECT
	[ItemID]				= i.itemID
	,[ScanCode]				= scn.scancode
	,[Product Description]	= lng.traitvalue
	,[POS Description]		= sht.traitvalue
	,[Package Unit]			= pu.traitvalue
	,[Food Stamp Eligible]	= 'not yet defined'
	,[Tare]					= 'not yet defined'
	,[Brand]				= hc.hierarchyclassname
FROM
	item i
JOIN scancode scn
	ON i.itemid = scn.itemid
JOIN scancodetype tscn
	ON scn.scancodetypeid = tscn.scancodetypeid
	AND tscn.scancodetypedesc = 'UPC'
JOIN itemtrait lng
	ON i.itemid = lng.itemid
JOIN trait tlng
	ON lng.traitID = tlng.traitID
	AND tlng.traitdesc = 'Product Description'
JOIN itemtrait sht
	ON i.itemid = sht.itemid
JOIN trait tsht
	ON sht.traitID = tsht.traitID
	AND tsht.traitdesc = 'POS Description'
JOIN itemtrait pu
	ON i.itemid = pu.itemid
JOIN trait tpu
	ON pu.traitID = tpu.traitID
	AND tpu.traitdesc = 'Package Unit'
JOIN itemhierarchyclass ihc
	ON i.itemid = ihc.itemid
JOIN hierarchyclass hc
	ON ihc.hierarchyclassid = hc.hierarchyclassid
JOIN hierarchy h
	ON hc.hierarchyid = h.hierarchyid
	AND h.hierarchyname = 'Brand'
GO
PRINT N'Altering [app].[vItemImport]...';


GO
ALTER VIEW [app].[vItemImport]
	AS
SELECT
	[ItemID]				= i.itemID
	,[ScanCode]				= scn.scanCode
	,[Product Description]	= lng.traitvalue
	,[POS Description]		= sht.traitvalue
	,[Package Unit]			= pu.traitvalue
	,[Food Stamp Eligible]	= '?'
	,[Tare]					= 'NAN'
FROM
	item i
JOIN scancode scn
	ON i.itemid = scn.itemid
JOIN itemtrait lng
	ON i.itemid = lng.itemid
JOIN trait tlng
	ON lng.traitID = tlng.traitID
	AND tlng.traitdesc = 'Product Description'
JOIN itemtrait sht
	ON i.itemid = sht.itemid
JOIN trait tsht
	ON sht.traitID = tsht.traitID
	AND tsht.traitdesc = 'POS Description'
JOIN itemtrait pu
	ON i.itemid = pu.itemid
JOIN trait tpu
	ON pu.traitID = tpu.traitID
	AND tpu.traitdesc = 'Package Unit'
GO
PRINT N'Altering [app].[vItemsAndTraits]...';


GO
ALTER VIEW [app].[vItemsAndTraits]
AS
/*
	This is a simple view to get the scancode and trait details (code, name, value) for all items.
*/
select
	i.itemID
	,sc.scanCode
	,t.traitDesc
	,it.traitValue
from item i
join ScanCode sc
on i.itemID = sc.itemID
join ItemTrait it
on i.itemID = it.itemID
join Trait t
on it.traitID = t.traitID
GO
PRINT N'Creating [app].[vValidatedItems]...';


GO
/*
Title: View of Validated Items with POS Attributes to be sent back to IRMA

Description: This view shows only validated scancodes with the all traits.
			 This view will not show non-validated scancodes and will not show
			 validated scancodes that do not have the following traits defined:
			 ValidationDate, Product Description, POS Description, Package Unit,
			 Food Stamp Eligible, POS Scale Tare and the hierarchies Brand and Tax.

Change History: TFS		Initials	Description		Date
				2625	BJL			View Creation	2014-04-11
*/
CREATE VIEW [app].[vValidatedItems]
	AS
SELECT
	 [ItemID]				= vi.[itemID]
	,[ValidationDate]		= vi.[traitValue]
	,[ScanCode]				= scn.[scancode]
	,[ScanCodeType]			= tscn.[scancodetypedesc]
	,[ProductDescription]	= lng.[traitValue]
	,[POSDescription]		= sht.[traitValue]
	,[PackageUnit]			= pu.[traitValue]
	,[FoodStampEligible]	= fs.[traitValue]
	,[Tare]					= pst.[traitValue]
	,[BrandId]				= hcb.[hierarchyclassID]
	,[Brand]				= hcb.[hierarchyclassname]
	,[Tax]					= hct.[hierarchyclassname]

FROM

-- Validation Date
(SELECT i.[itemId], vd.[traitValue]
FROM [Item] i				
JOIN [ItemTrait] vd		ON i.[itemID] = vd.[itemid]
JOIN [Trait] tvd			ON vd.[traitID] = tvd.[traitID]
							AND tvd.[traitdesc] = 'Validation Date') as vi

-- ScanCode for UPC
JOIN [scancode] scn		ON vi.[itemid] = scn.[itemid]
JOIN [scancodetype] tscn	ON scn.[scancodetypeid] = tscn.[scancodetypeid]

-- Product Description
JOIN [itemtrait] lng		ON vi.[itemid] = lng.[itemid]
JOIN [trait] tlng			ON lng.[traitID] = tlng.[traitID]
						AND tlng.[traitDesc] = 'Product Description'

-- POS Description
JOIN [ItemTrait] sht		ON vi.[itemid] = sht.[itemid]
JOIN [trait] tsht			ON sht.[traitID] = tsht.[traitID]
						AND tsht.[traitdesc] = 'POS Description'

-- Package Unit
JOIN [itemtrait] pu		ON vi.[itemid] = pu.[itemid]
JOIN [trait] tpu			ON pu.[traitID] = tpu.[traitID]
						AND tpu.[traitdesc] = 'Package Unit'

-- Food Stamp Eligible
JOIN [itemtrait] fs		ON vi.[itemid] = fs.[itemid]
JOIN [trait] tfs			ON fs.[traitID] = tfs.[traitID]
						AND tfs.[traitdesc] = 'Food Stamp Eligible'

-- POS Scale Tare
JOIN [itemtrait] pst		ON vi.[itemid] = pst.[itemid]
JOIN [trait] tpst			ON pst.[traitID] = tpst.[traitID]
						AND tpst.[traitdesc] = 'POS Scale Tare'

-- Brand
JOIN [itemhierarchyclass] ihcb	ON vi.[itemid] = ihcb.[itemid]
JOIN [hierarchyclass] hcb			ON ihcb.[hierarchyclassid] = hcb.[hierarchyclassid]
JOIN [hierarchy] hb				ON hcb.[hierarchyid] = hb.[hierarchyid]
								AND hb.[hierarchyname] = 'Brand'

-- Tax
JOIN [itemhierarchyclass] ihct	ON vi.[itemid] = ihct.[itemid]
JOIN [hierarchyclass] hct			ON ihct.[hierarchyclassid] = hct.[hierarchyclassid]
JOIN [hierarchy] ht				ON hct.[hierarchyid] = ht.[hierarchyid]
								AND ht.[hierarchyname] = 'Tax'
GO
PRINT N'Altering [app].[pivot_query]...';


GO
ALTER procedure [app].pivot_query
   (
   @query         varchar(MAX),
   @row_fields    varchar(8000),
   @col_field     varchar(1000),
   @agg_func_list varchar(8000),
   @dest_table    varchar(1000) = null,
   @show_query    char(1) = null
   )
as
--**************************************************************************
-- Procedure: pivot_query()
--    Author: Ron Savage
--      Date: 05/20/2007
--
-- Description:
-- This procedure makes a pivot table out of the input arguments using the
-- spiffy new PIVOT feature in SQL Server 2005.  Only up to 147 columns
-- of pivoted data though .. more crashes it.
--
-- Syntax:
-- pivot_query '<query>', '<field list for each row>', '<pivot column>', '<aggregate expression list>', '[<results table>]', '[<show query>]'
--
--    '<query>'                     - Query defining the data to pivot
--    '<field list for each row>'   - List of fields to show for each row of data, to the left of the pivot (comma delimited)
--    '<pivot column>'              - The column that contains the column headers of the pivoted data
--    '<aggregate expression list>' - A list of function(field) expressions to calculate for the pivot.
--    '[<results table>]'           - An optional table to create for the results of the pivot, it will be dropped and re-created
--    '[<show query>]'              - An optional value to have the proc show the pivot query for debugging. Any char value makes it print
--
-- Change History:
-- Date        Init. Description
-- 05/12/2014  RS    Removed ##log_table to avoid multi-process contention and fixed a bug with handling
--                   new data types.
-- 10/09/2009  RS    Updated the internal temp table to be named '##tmp_' + @PROCID + @SPID so each
--                   server process will get it's own temp table - multiple threads each get the same PROCID.
-- 10/08/2007  RS    Fixed sum() and count() cases for sql_variants.
-- 10/07/2007  RS    Altered to use the sql_variant type field in the inner temp tables to allow
--                   multiple aggregate fields to be different types, and to convert the sql_variant
--                   back to the original type on output.
-- 09/14/2007  RS    Increased parsing variable sizes to handle longer field name combinations.
-- 08/02/2007  RS    Copied from pivot_table and modified for passing in a query.
-- **************************************************************************
begin
   set nocount on;

   if ( @show_query is not null ) print char(13) + 'Starting ...';

   --**************************************************************************
   -- Declare some variables
   --**************************************************************************
   declare @pivot_sql  varchar(MAX);
   declare @sql        varchar(MAX);
   declare @piv_value  varchar(300);
   declare @piv_type   varchar(300);

   set @pivot_sql = '';
   set @sql       = '';

   --**************************************************************************
   -- Declare variables for parsing the agg expression list
   --**************************************************************************
   declare @sub_start  integer;
   declare @sub_len    integer;
   declare @del_loc    integer;
   declare @agg_exp    varchar(1000);
   declare @agg_func   varchar(300);
   declare @agg_lbl    varchar(300);
   declare @agg_tag    varchar(300);
   declare @agg_field  varchar(1000);
   declare @agg_fld    varchar(300);
   declare @tmp_table  varchar(300);
   declare @fld_index  integer;
   declare @tname      varchar(300);
   declare @tbl_select varchar(MAX);

   set @sub_start = 1;
   set @sub_len   = 0;
   set @fld_index = 1;

   --**************************************************************************
   -- Declare a process id specific temp table
   --**************************************************************************
   set @tmp_table = '##tmp_' + cast(@@procid as varchar(15))+ cast(@@spid as varchar(15));

   --**************************************************************************
   -- Drop if the temp table exists
   --**************************************************************************
--    if exists (select * from dbo.sysobjects where  name = @tmp_table)
   BEGIN TRY
      exec('drop table ' + @tmp_table);
   END TRY
   BEGIN CATCH
--       print 'Woo! Caught one!';
   END CATCH

   --**************************************************************************
   -- Loop through each aggregate expression and insert the results into
   -- the temp table with a category label to pivot on when done
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'Looping and parsing [' + @agg_func_list + '] ...';

   while ( @sub_start < len(@agg_func_list) )
      begin
      set @del_loc   = charindex(',', @agg_func_list, @sub_start);

      if ( @del_loc > 0 )
         set @sub_len   = @del_loc - @sub_start;
      else
         set @sub_len   = len(@agg_func_list) - @sub_start + 1;

      --**************************************************************************
      -- Parse the expression, field and function and label
      --**************************************************************************
      set @agg_exp  = ltrim(rtrim(substring(@agg_func_list, @sub_start, @sub_len)));
      set @agg_fld  = ltrim(rtrim(substring(@agg_exp, charindex('(',@agg_exp) + 1, charindex(')',@agg_exp) - charindex('(',@agg_exp) - 1)));
      set @agg_func = ltrim(rtrim(substring(@agg_exp, 1, charindex('(',@agg_exp) - 1)));
      set @agg_lbl  = ltrim(rtrim(reverse(substring(reverse(@agg_exp), 1, charindex(' ',reverse(@agg_exp))))));

      if ( @agg_fld = '*' ) set @agg_fld = '1';

      set @agg_tag = case
                        when ( @fld_index = 1 and @agg_lbl = '' ) then 'cast(' + @col_field + ' as varchar(100))'
                        when ( @fld_index > 1 and @agg_lbl = '' ) then 'cast(' + @col_field + ' as varchar(100)) + ''_' + @agg_func + '_' + @agg_fld + ''''
                        else 'cast(' + @col_field + ' as varchar(100)) + ''_' + @agg_lbl + ''''
                     end

      if ( @show_query is not null ) print char(13) + 'Processing: [' + @agg_exp + '] into [' + @agg_func + '] [' + @agg_fld + '] ...';

      --**************************************************************************
      -- If it's the first first expression, define a select - into SQL
      --**************************************************************************
      if ( @sub_start = 1 )
         set @sql = 'select ' + @row_fields + ', ' +
                                @col_field + ' as col_field, ' +
                                @agg_tag + ' as cat, ' +
                                cast(@fld_index as varchar(3)) + ' as fld_num, ' +
                                'max(cast(' + char(13) +
                                'case cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10))' + char(13) +
                                '   when ''decimal''  then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''numeric''  then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''char''     then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nchar''    then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''varchar''  then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nvarchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   else                   cast(isnull(sql_variant_property(' + @agg_fld + ', ''BaseType''),''varchar(100)'') as varchar(20))' + char(13) +
                                'end as varchar(100))) as fld_type,' + char(13) +
                                'cast(' + @agg_func + '(' + @agg_fld + ') as sql_variant) as value ' + char(13) + 'into ' + @tmp_table + char(13) +
                                ' from (' + @query + ') as qry ' + char(13) +
                                ' group by ' + @row_fields + ', ' + @col_field  +
                                ',' + @agg_tag;
      else
      --**************************************************************************
      -- Otherwise, define an insert-into-select SQL
      --**************************************************************************
         set @sql = 'insert into ' + @tmp_table + ' select ' + @row_fields + ', ' +
                                @col_field + ' as col_field, '+
                                @agg_tag + 'as cat, ' +
                                cast(@fld_index as varchar(3)) + ' as fld_num, ' +
                                'max(cast(' + char(13) +
                                'case cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10))' + char(13) +
                                '   when ''decimal'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''numeric'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''Precision'') as varchar(10)) + '','' + cast(sql_variant_property(' + @agg_fld + ', ''Scale'') as varchar(10)) + '')''' + char(13) +
                                '   when ''char'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''varchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   when ''nvarchar'' then cast(sql_variant_property(' + @agg_fld + ', ''BaseType'') as varchar(10)) + ''('' + cast(sql_variant_property(' + @agg_fld + ', ''MaxLength'') as varchar(10)) + '')''' + char(13) +
                                '   else cast(isnull(sql_variant_property(' + @agg_fld + ', ''BaseType''),''varchar(100)'') as varchar(20))' + char(13) +
                                'end as varchar(100))) as fld_type,' + char(13) +
                                'cast(' + @agg_func + '(' + @agg_fld + ') as sql_variant) as value ' + char(13) +
                                ' from (' + @query + ') as qry ' + char(13) +
                                ' group by ' + @row_fields + ', ' + @col_field  +
                                ',' + @agg_tag;

      set @sub_start = @sub_start + @sub_len + 1;
      set @fld_index = @fld_index + 1;

      exec(@sql);
      end

   --**************************************************************************
   -- Update the input variables to the new temp table and fields
   --**************************************************************************
   set @tname        = @tmp_table;
   set @col_field    = 'cat';
   set @agg_field    = 'value';

   if ( lower(@agg_func) = 'count' ) set @agg_func = 'sum';

   if ( @show_query is not null ) print char(13) + 'Changed table and fields to refer to the temp:  [' + @tname + '] [' + @col_field + '] [' + @agg_field + '] ...';

   --**************************************************************************
   -- Start building the PIVOT SQL
   --**************************************************************************
   set @pivot_sql = @pivot_sql +  'select' + char(13);
   set @pivot_sql = @pivot_sql +  '   pvt.*' + char(13);

   --**************************************************************************
   -- Put all the input arguments in thier proper places in the query
   --**************************************************************************
   set @pivot_sql = @pivot_sql +  'from' + char(13);
   set @pivot_sql = @pivot_sql +  '   (select ' + @row_fields + ', ' + @col_field + ', isnull(' + @agg_field + ',0) as '+ @agg_field + ' from ' + @tname + ') as c' + char(13);
   set @pivot_sql = @pivot_sql +  '       PIVOT' + char(13);
   set @pivot_sql = @pivot_sql +  '          (' + char(13);
--    set @pivot_sql = @pivot_sql +  '          ' + @agg_func + '(' + @agg_field + ')' + char(13);
   set @pivot_sql = @pivot_sql +  '          max(' + @agg_field + ')' + char(13);
   set @pivot_sql = @pivot_sql +  '          for ' + @col_field + ' in' + char(13);
   set @pivot_sql = @pivot_sql +  '             ( ';

   --**************************************************************************
   -- Get all the unique values of the Pivot column in the data table,
   -- these will become the pivoted columns.  For some reason, the PIVOT
   -- chokes if there are more than 147 result columns ... determined
   -- experimentally, so your mileage may vary.
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'Creating the #pivot_values table ...';
   create table #pivot_values ( piv_order  integer, fld_type varchar(100), piv_fldsort   varchar(100), piv_fld   varchar(100) );

   set @sql ='insert into #pivot_values select distinct top 147 fld_num, fld_type, col_field, ' + @col_field  + ' from ' + @tname + ' order by col_field, fld_num';

   exec(@sql);

   --**************************************************************************
   -- Loop through the values and add them to the PIVOT query SQL
   --**************************************************************************
   declare @piv_value_count integer;
   set @piv_value_count = 0;
   set @tbl_select = 'select ' + @row_fields + ',';

   declare piv_cursor cursor for
      select piv_fld, fld_type from #pivot_values order by piv_fldsort, piv_order;

   open piv_cursor;
   fetch next from piv_cursor into @piv_value,@piv_type;

   while @@FETCH_STATUS = 0
   begin
      set @pivot_sql  = @pivot_sql +  '[' + rtrim(isnull(@piv_value,'null')) + ']';
      set @tbl_select = @tbl_select + 'cast([' + rtrim(isnull(@piv_value,'null')) + '] as ' + rtrim(isnull(@piv_type,'null')) + ') as [' + rtrim(isnull(@piv_value,'null')) + ']';

      fetch next from piv_cursor into @piv_value,@piv_type;

      if @@FETCH_STATUS = 0
      begin
         set @pivot_sql  = @pivot_sql  +  ', ';
         set @tbl_select = @tbl_select +  ', ' + char(13);
      end

      set @piv_value_count = @piv_value_count + 1;
   end
   close piv_cursor;

   --**************************************************************************
   -- Finish off the PIVOT SQL
   --**************************************************************************
   set @pivot_sql = @pivot_sql +  ' )' + char(13);
   set @pivot_sql = @pivot_sql +  '          ) as pvt' + char(13);

   --**************************************************************************
   -- If we have a destination table, add the "into" statements
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'checking for destination table option ...';
   if ( @dest_table is not null )
      begin
         if ( @show_query is not null ) print char(13) + 'Dropping the dest table [' + @dest_table + '] if it exists ...';

         set @sql ='drop table ' + @dest_table;

         BEGIN TRY
            exec(@sql);
         END TRY
         BEGIN CATCH
         END CATCH

         set @pivot_sql = @tbl_select + ' into ' + @dest_table + ' from (' + @pivot_sql + ') as piv ' + char(13);
      end
   else
      set @pivot_sql = @tbl_select + ' from (' + @pivot_sql + ') as piv ' + char(13);

   if ( @show_query is not null ) print char(13) + 'adding order by clause ...';
   set @pivot_sql = @pivot_sql +  'order by' + char(13);
   set @pivot_sql = @pivot_sql +  '   ' + @row_fields + char(13);

   --**************************************************************************
   -- Run the PIVOT SQL
   --**************************************************************************
   if ( @show_query is not null ) print char(13) + 'Running the Pivot SQL ...' + char(13) + @pivot_sql;
   if ( @piv_value_count > 0 )
      exec(@pivot_sql);
   else
      select 'There was no data to pivot.';

   BEGIN TRY
      exec('drop table ' + @tmp_table);
   END TRY
   BEGIN CATCH
   END CATCH
   return;
end
GO
PRINT N'Altering [app].[UpdateItemHierarchyClass]...';


GO
ALTER PROCEDURE [app].[UpdateItemHierarchyClass]
	/*
		NOTE: The list we are getting can have item-hier-class entries for many items and any/all hierarchies
		for those items (brand, browsing, merch, tax, etc.).
	*/
	@itemList [app].ItemListByHierarchyClassType READONLY
AS

	declare @taskName varchar(32)
	select @taskName = 'iCon.UpdateItemHierarchyClass'

	/*
		For item-hierarchy-class updates, we do the following:
		1) Delete any existing entry for the target item and parent hierarchy.
		2) Add/Insert item-hier-class entry.
	*/

	declare
		@removeItemHierClassList ItemListByHierarchyClassType,
		@expectedRemoveCount int, 
		@actualRemoveCount int,
		@localeID int

	set @localeID = 1;

	/*
		Identify existing hier-class entries for all items that need to be removed.
	*/

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Identifying existing item-hier-class entries to be removed...';
	insert into @removeItemHierClassList
		select
			sc.itemID,
			oldIHC.hierarchyClassID,
			localeID = 1
		from @itemList il  -- We use the passed list of item-hier-class entries to identify existing entries that we need to delete before we can add the new entry.
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.itemID = sc.itemID
		join ItemHierarchyClass oldIHC (nolock) -- Get hier class entries for each item.
			on sc.itemID = oldIHC.itemID
		join HierarchyClass currentHC (nolock) -- We need parent hier for the hier class, so we have to go through the hier class table to get hier ID.
			on oldIHC.hierarchyClassID = currentHC.hierarchyClassID
		join Hierarchy currentH (nolock) -- This gives us all hiers for hier classes linked to each item (brand, browsing, merch, etc.).
			on currentHC.hierarchyID = currentH.hierarchyID
		join HierarchyClass newHC (nolock) -- We need to lookup the new hier class we are assigning and match it to the same hier for any hier class currently linked to the item.
			on il.hierarchyClassID = newHC.hierarchyClassID
		join Hierarchy newH (nolock) -- This gives us the target parent hier for the hier class being assigned so we can remove existing entries before adding the new assignment entry.
			on newH.hierarchyID = newHC.hierarchyID
		where
			currentH.hierarchyID = newH.hierarchyID -- This links the hier, like "Brand", we are assigning to any existing hier entry for the item so we can remove it.

	select @expectedRemoveCount = @@rowcount

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Removing existing item-hier-class entries...';
	-- Remove existing item-hier-class entries.
	delete ItemHierarchyClass
	from ItemHierarchyClass ihc
	join @removeItemHierClassList del
		on ihc.itemID = del.itemID
		and ihc.hierarchyClassID = del.hierarchyClassID
		and isnull(ihc.localeID, 1) = isnull(del.localeID, 1)

	-- Determine rows affected to compare to what we thought should have been removed.
	select @actualRemoveCount = @@rowcount

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Verifying expected and actual item-hier-class rows removed...';
	if @actualRemoveCount <> @expectedRemoveCount
	begin
		DECLARE @ErrorMessage NVARCHAR(4000);
		select @ErrorMessage = 'The number of expected ItemHierarchyClass entries identified for removal [' + cast(@expectedRemoveCount as varchar) + ']'
		+ ' did not match the number affected rows from the DELETE attempt [' + cast(@actualRemoveCount as varchar) + ']'
		RAISERROR (
			@ErrorMessage -- Message text.
			,11 -- Severity.
			,0 -- State.
		)

	end

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding new item-hier-class entries...';
	-- Add new item-hier-class entries.
	insert into ItemHierarchyClass
		select * from @itemList

	-- Return item IDs where the item's hierarchy class has changed.
	declare @updatedItems table(
		itemID int,
		originalHierarchyClassID int,
		newHierarchyClassID int)
	
	-- Get newly added hierarchy class IDs
	insert into @updatedItems
	select il.itemID, 0, il.hierarchyClassID
	from @itemList il
	where	il.itemID not in
			(select itemID from @removeItemHierClassList)
		and
			il.hierarchyClassID not in
			(select hierarchyClassID from @removeItemHierClassList)

	-- Get updated hierarchy class IDs
	insert into @updatedItems
	select il.itemID, rihcl.itemID, il.itemID
	from @itemList il
	join @removeItemHierClassList rihcl 
		on il.itemID = rihcl.itemID

	--Return updated item IDs
	select itemID from @updatedItems

return
GO
PRINT N'Creating [app].[UpdateItemListByTrait]...';


GO

CREATE PROCEDURE [app].[UpdateItemListByTrait]
	@itemList app.ItemListByTraitType READONLY
AS

/*

We get a list of items and their traits (each different trait is a separate row),
so we update by linking the item and trait code coming in to the same fields in the ItemTrait table.

*/

declare @updatedItems table(
	itemID int,
	originalTraitValue nvarchar(255),
	newTraitValue nvarchar(255)
)

update ItemTrait
set traitValue = il.traitValue
output	inserted.itemID,
		deleted.traitValue,
		inserted.traitValue
into @updatedItems
from
	@itemList il
	join item i
		on il.itemID = i.itemID
	join ItemTrait it
		on i.itemID = it.itemID
where
	it.traitID = il.traitID -- Link trait names.

-- Return item IDs where the item's traits have changed.

select itemID
from @updatedItems ui
where ui.newTraitValue <> ui.originalTraitValue

return
GO
PRINT N'Creating [app].[AddEventQueue]...';


GO
CREATE PROCEDURE [app].[AddEventQueue]
	@EventName NVARCHAR(255), 
    @EventQueueEntries [app].[EventQueueEntriesType] READONLY,
	@RegionList [app].[RegionAbbrType] READONLY

AS
BEGIN
    SET NOCOUNT ON;

	BEGIN TRY;

		BEGIN TRANSACTION;

		----------------------------------------------
		-- Verify the EventType.EventName
		----------------------------------------------
		DECLARE @EventId INT;
		SELECT 	@EventId = (SELECT [EventId] FROM [app].[EventType] WHERE [EventName] = @EventName);

		IF @EventId IS NULL
		BEGIN
			-- RAISERROR with severity 11-19 will cause execution to jump to the CATCH block.
			RAISERROR('No EventName found matching the @EventName ''%s''!', 16, 1, @EventName);
		END

		----------------------------------------------
		-- Queue the Event
		----------------------------------------------
		DECLARE @eventCount INT, @regionCount INT
		SELECT @eventCount = (SELECT COUNT(*) FROM @EventQueueEntries)
		SELECT @regionCount = (SELECT COUNT(*) FROM @RegionList)

		IF (@eventCount > 0 AND @regionCount > 0) -- EVENTS AND REGIONS TO QUEUE UP
		BEGIN
			INSERT INTO [app].[EventQueue] ([EventId], [EventMessage], [EventReferenceId], [RegionCode])
			SELECT @EventId, e.EventMessage, e.EventReferenceId, r.RegionAbbr
			FROM @EventQueueEntries e 
			CROSS APPLY @RegionList r
		END
		ELSE IF (@eventCount > 0 AND @regionCount = 0)-- EVENTS, BUT NO REGIONS --> USE THE NULL REGION
		BEGIN
			INSERT INTO [app].[EventQueue] ([EventId], [EventMessage], [EventReferenceId], [RegionCode])
			SELECT @EventId, e.EventMessage, e.EventReferenceId, NULL
			FROM @EventQueueEntries e 
		END
		ELSE IF (@eventCount = 0 AND @regionCount > 0)-- NO EVENTS, BUT REGIONS
		BEGIN
			INSERT INTO [app].[EventQueue] ([EventId], [EventMessage], [EventReferenceId], [RegionCode])
			SELECT @EventId, NULL, NULL, r.RegionAbbr
			FROM @RegionList r
		END
		-- ELSE -- NO EVENTS AND NO REGIONS DO NOTHING

		IF @@TRANCOUNT > 0
			COMMIT TRANSACTION;

	END TRY
	BEGIN CATCH

		IF @@TRANCOUNT > 0
			ROLLBACK TRANSACTION;

		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		SET NOCOUNT OFF;

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH;

    SET NOCOUNT OFF;
END;
GO
PRINT N'Creating [app].[GenerateItemUpdateEvents]...';


GO
CREATE procedure [app].[GenerateItemUpdateEvents] 
	@updatedItemIDs app.UpdatedItemIDsType READONLY
as
	DECLARE @distinctItemIDs app.UpdatedItemIDsType,
			@itemUpdateEventType int,
			@validationDateTraitID int

	SET @itemUpdateEventType = 2
	SET @validationDateTraitID = 49
	
	INSERT @distinctItemIDs 
	SELECT DISTINCT itemID from @updatedItemIDs

	INSERT INTO app.EventQueue
	SELECT @itemUpdateEventType, sc.scanCode, dii.itemID, iis.regionCode, GETDATE()
	FROM @distinctItemIDs dii
	JOIN ScanCode sc
		ON sc.itemID = dii.itemID
	JOIN app.IRMAItemSubscription iis
		ON sc.scanCode = iis.identifier
	JOIN Item i
		ON sc.itemID = i.itemID
	JOIN ItemTrait it
		ON i.itemID = it.itemID
		AND it.traitID = @validationDateTraitID
	WHERE sc.scanCodeTypeID = 1
GO
PRINT N'Creating [app].[GenerateItemUpdateMessages]...';


GO

--************************************************************************
-- app.GenerateItemUpdateMessages
-- This stored procedure is called by the ItemImport.sql stored procedure.
-- This will generate a Product Message for the ESB for each itemID
-- that was updated in the ItemImport.sql stored proc
--************************************************************************

--************************************************************************
-- app.GenerateItemUpdateMessages
-- This stored procedure is called by the ItemImport.sql stored procedure.
-- This will generate a Product Message for the ESB for each itemID
-- that was updated in the ItemImport.sql stored proc
--************************************************************************

CREATE PROCEDURE [app].[GenerateItemUpdateMessages] 
	@updatedItemIDs app.UpdatedItemIDsType READONLY

AS

DECLARE @distinctItemIDs app.UpdatedItemIDsType;
INSERT @distinctItemIDs 
SELECT DISTINCT itemID FROM @updatedItemIDs

DECLARE
	@localeID int,
	@productDescriptionTraitID int,
	@posTraitID int,
	@packageUnitTraitID int,
	@foodStampEligibleTraitID int,
	@posScaleTareTraitID int,
	@departmentSaleTraitID int,
	@brandHierarchyID int,
	@browsingClassID int,
	@merchandisingClassID int,
	@financialClassID int,
	@taxClassID int,
	@validationDateTraitID int,
	@readyMessageStatusID int,
	@productMessageTypeID int,
	@merchFinMappingTraitID int;

SELECT @localeID = l.localeID FROM Locale l WHERE l.localeName = 'Whole Foods';
SELECT @productDescriptionTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Product Description';
SELECT @posTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Pos Description';
SELECT @packageUnitTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Package Unit';
SELECT @foodStampEligibleTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Food Stamp Eligible';
SELECT @posScaleTareTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Pos Scale Tare';
SELECT @departmentSaleTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Department Sale';
SELECT @brandHierarchyID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Brand';
SELECT @browsingClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Browsing';
SELECT @merchandisingClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Merchandising';
SELECT @financialClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Financial';
SELECT @taxClassID = h.hierarchyID FROM Hierarchy h WHERE h.hierarchyName = 'Tax';
SELECT @validationDateTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Validation Date';
SELECT @readyMessageStatusID = s.MessageStatusId FROM app.MessageStatus s WHERE s.MessageStatusName = 'Ready';
SELECT @productMessageTypeID = t.MessageTypeId FROM app.MessageType t WHERE t.MessageTypeName = 'Product';
SELECT @merchFinMappingTraitID = t.traitID FROM Trait t WHERE t.traitDesc = 'Merch Fin Mapping';

-- Get Browsing ItemHierarchyClass relationships for left join
select
	ihc.itemID,
	hc.hierarchyClassID,
	hc.hierarchyClassName,
	hc.hierarchyLevel,
	hc.hierarchyID,
	hc.hierarchyParentClassID
into #tempBrowsing
from
	ItemHierarchyClass		ihc
	JOIN HierarchyClass		hc on ihc.hierarchyClassID = hc.hierarchyClassID AND hc.hierarchyID = @browsingClassID
	JOIN @distinctItemIDs	i on ihc.itemID = i.itemID

-- Main
print 'Inserting into app.MessageQueueProduct'
INSERT INTO app.MessageQueueProduct
SELECT
	@productMessageTypeID			as MessageTypeID,
	@readyMessageStatusID			as MessageStatusID,
	NULL							as MessageHistoryID,
	dii.itemID						as ItemID,
	@localeID						as LocaleID,
	it.itemTypeCode					as ItemTypeCode,
	it.itemTypeDesc					as ItemTypeDesc,
	sc.scanCodeID					as ScanCodeID,
	sc.scanCode						as ScanCode,
	sct.scanCodeTypeID				as ScanCodeTypeID,
	sct.scanCodeTypeDesc			as ScanCodeTypeDesc,
	pd.traitValue					as ProductDescription,
	pos.traitValue					as PosDescription,
	pu.traitValue					as PackageUnit,
	fse.traitValue					as FoodStamp,
	posst.traitValue				as PosScaleTare,
	CASE 
		WHEN ds.traitValue IS NULL THEN '0'
		ELSE '1'
	END								as DepartmentSale,
	brandhc.hierarchyClassID		as BrandID,
	brandhc.hierarchyClassName		as BrandName,
	brandhc.hierarchyLevel			as BrandLevel,
	brandhc.hierarchyParentClassID	as BrandParentId,
	browhc.hierarchyClassID			as BrowsingId,
	browhc.hierarchyClassName		as BrowswingName,
	browhc.hierarchyLevel			as BrowsingLevel,
	browhc.hierarchyParentClassID	as BrowsingParentId,
	merchhc.hierarchyClassID		as MerchandisingId,
	merchhc.hierarchyClassName		as MerchandisingName,
	merchhc.hierarchyLevel			as MerchandisingLevel,
	merchhc.hierarchyParentClassID	as MerchandisingParentId,
	taxhc.hierarchyClassID			as TaxID,
	taxhc.hierarchyClassName		as TaxName,
	taxhc.hierarchyLevel			as TaxLevel,
	taxhc.hierarchyParentClassID	as TaxParentId,
	finhc.hierarchyClassID			as FinancialId,
	finhc.hierarchyClassName		as FinancialName,
	finhc.hierarchyLevel			as FinancialLevel,
	finhc.hierarchyParentClassID	as FinancialParentId,
	SYSDATETIME()					as InsertDate
FROM @distinctItemIDs dii
JOIN Item i
	ON dii.itemID = i.itemID
JOIN ItemType it
	ON i.itemTypeID = it.itemTypeID
JOIN ScanCode sc
	ON i.itemID = sc.itemID
JOIN ScanCodeType sct
	ON sc.scanCodeTypeID = sct.scanCodeTypeID
JOIN ItemTrait vdit
	ON i.itemID = vdit.itemID
	AND vdit.traitID = @validationDateTraitID -- Only generating messages for items that have been validated
JOIN ItemTrait pd
	ON i.itemID = pd.itemID
	AND pd.traitID = @productDescriptionTraitID
JOIN ItemTrait pos
	ON i.itemID = pos.itemID
	AND pos.traitID = @posTraitID
JOIN ItemTrait pu
	ON i.itemID = pu.itemID
	AND pu.traitID = @packageUnitTraitID
JOIN ItemTrait fse
	ON i.itemID = fse.itemID
	AND fse.traitID = @foodStampEligibleTraitID
JOIN ItemTrait posst
	ON i.itemID = posst.itemID
	AND posst.traitID = @posScaleTareTraitID
JOIN ItemHierarchyClass brandihc
	ON i.itemID = brandihc.itemID
JOIN HierarchyClass brandhc
	ON brandihc.hierarchyClassID = brandhc.hierarchyClassID
	AND brandhc.hierarchyID = @brandHierarchyID
JOIN ItemHierarchyClass ihcm
	ON i.itemID = ihcm.itemID
JOIN HierarchyClass merchhc
	ON ihcm.hierarchyClassID = merchhc.hierarchyClassID
	AND merchhc.hierarchyID = @merchandisingClassID
JOIN HierarchyClassTrait merchhct
	ON merchhc.hierarchyClassID = merchhct.HierarchyClassID
	AND merchhct.traitID = @merchFinMappingTraitID
JOIN HierarchyClass finhc
	ON merchhct.traitValue = finhc.hierarchyClassName
	AND finhc.hierarchyID = @financialClassID
JOIN ItemHierarchyClass ihct
	ON i.itemID = ihct.itemID
JOIN HierarchyClass taxhc
	ON ihct.hierarchyClassID = taxhc.hierarchyClassID
	AND taxhc.hierarchyID = @taxClassID
LEFT JOIN ItemTrait ds
	ON i.itemID = ds.itemID
	AND ds.traitID = @departmentSaleTraitID
LEFT JOIN #tempBrowsing browhc on i.itemID = browhc.itemID
GO
PRINT N'Creating [app].[UpdateTaxHierarchyClass]...';


GO
CREATE PROCEDURE [app].[UpdateTaxHierarchyClass] 
	@TaxHierarchyClasses app.TaxHierarchyClassUpdateType READONLY,  
	@Regions app.RegionAbbrType READONLY

AS
BEGIN

	SET NOCOUNT ON;
	
	BEGIN TRY;

		BEGIN TRANSACTION;

			DECLARE @IdToNameMap as TABLE
			(
				hierarchyClassID int,
				cchHierarchyClassID nvarchar(7),
				oldHierarchyClassName nvarchar(255),
				newHierarchyClassName nvarchar(255)
			);

			DECLARE @UpdatedTaxHierarchyClasses as Table
			(
				hierarchyClassID int,
				cchHierarchyClassID nvarchar(7),
				hierarchyClassName nvarchar(255)
			);

			DECLARE @NewTaxHierarchyClasses AS TABLE
			(
				hierarchyClassID int,
				cchHierarchyClassID nvarchar(7),
				hierarchyClassName nvarchar(255)
			);

			DECLARE @TaxHierarchyID int;
			SET @TaxHierarchyID = (SELECT hierarchyID FROM dbo.Hierarchy WHERE hierarchyName = 'Tax');

			----------------------------------------------------------------------
			-- Create a mapping between the Tax IDs and the HierarchyClass IDs
			----------------------------------------------------------------------
			INSERT	@IdToNameMap (hierarchyClassID, cchHierarchyClassID, oldHierarchyClassName, newHierarchyClassName)
			SELECT	hc.hierarchyClassID,
					thc.HierarchyClassID,
					hc.HierarchyClassName,
					thc.HierarchyClassName
			FROM	(SELECT hierarchyClassID, hierarchyClassName 
					 FROM dbo.HierarchyClass 
					 WHERE hierarchyId = @TaxHierarchyID) AS hc
			INNER JOIN @TaxHierarchyClasses thc ON hc.hierarchyClassName LIKE thc.HierarchyClassID + '%';

			----------------------------------------------------------------------
			-- Update current Tax HierarchyClasses
			----------------------------------------------------------------------
			INSERT @UpdatedTaxHierarchyClasses (hierarchyClassID, cchHierarchyClassID, hierarchyClassName)
			SELECT itnm.hierarchyClassID,
				   itnm.cchHierarchyClassID,
				   itnm.newHierarchyClassName
			FROM @IdToNameMap itnm
			WHERE itnm.oldHierarchyClassName <> itnm.newHierarchyClassName;
			
			UPDATE dbo.HierarchyClass
			SET hierarchyClassName = uthc.hierarchyClassName
			FROM dbo.HierarchyClass hc
			INNER JOIN @UpdatedTaxHierarchyClasses uthc
			ON hc.hierarchyClassID = uthc.hierarchyClassID;

			----------------------------------------------------------------------
			-- Add new Tax HierarchyClasses
			----------------------------------------------------------------------
			INSERT HierarchyClass 
				OUTPUT INSERTED.hierarchyClassID, NULL, INSERTED.hierarchyClassName
					INTO @NewTaxHierarchyClasses
			SELECT	1,
					@TaxHierarchyID,
					NULL,
					thc.hierarchyClassName 
			FROM @TaxHierarchyClasses thc
			WHERE thc.HierarchyClassName NOT IN (SELECT hierarchyClassName FROM @UpdatedTaxHierarchyClasses)
			AND thc.HierarchyClassName NOT IN (SELECT hierarchyClassName FROM dbo.[HierarchyClass]);

			-- Get the CCH hierarchyClassID to be used as the iCon.app.EventQueue.EventMessage
			UPDATE @NewTaxHierarchyClasses
			SET cchHierarchyClassID = thc.HierarchyClassID
			FROM @NewTaxHierarchyClasses nthc
			INNER JOIN @TaxHierarchyClasses thc ON nthc.hierarchyClassName = thc.HierarchyClassName

			----------------------------------------------------------------------
			-- Add Update Tax HierarchyClass events in EventQueue
			----------------------------------------------------------------------
			DECLARE @UpdateTaxEventQueueEntries app.EventQueueEntriesType;
			INSERT @UpdateTaxEventQueueEntries (EventMessage, EventReferenceId)
			SELECT cchHierarchyClassID, hierarchyClassID FROM @UpdatedTaxHierarchyClasses;

			IF ((SELECT COUNT(*) FROM @UpdatedTaxHierarchyClasses) > 0)
			BEGIN
				EXEC app.AddEventQueue 
					@EventName = 'Tax Name Update',
					@EventQueueEntries  = @UpdateTaxEventQueueEntries,
					@RegionList = @Regions;
			END

			----------------------------------------------------------------------
			-- Add New Tax HierarchyClass events in EventQueue
			----------------------------------------------------------------------			
			DECLARE @NewTaxEventQueueEntries app.EventQueueEntriesType;
			INSERT @NewTaxEventQueueEntries (EventMessage, EventReferenceId)
			SELECT cchHierarchyClassID, hierarchyClassID FROM @NewTaxHierarchyClasses;
			
			IF ((SELECT COUNT(*) FROM @NewTaxHierarchyClasses) > 0)
			BEGIN
				EXEC app.AddEventQueue 
					@EventName = 'New Tax Hierarchy',
					@EventQueueEntries  = @NewTaxEventQueueEntries,
					@RegionList = @Regions;
			END
			
			IF @@TRANCOUNT > 0
			COMMIT TRANSACTION;

	END TRY
	BEGIN CATCH

		IF @@TRANCOUNT > 0
			ROLLBACK TRANSACTION;

		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		SET NOCOUNT OFF;

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH;

    SET NOCOUNT OFF;
END;
GO
PRINT N'Altering [app].[ItemImport]...';


GO

ALTER PROCEDURE [app].[ItemImport]
	@itemList app.ItemImportType READONLY
	,@userName nvarchar(255)
AS
/*

	We receive a list of items and their traits in a single row.
	We build one list containing all the different traits for an item on separate rows.
	This way, we only call the update once, but the list could be larger than doing one trait at a time.
	We only include entries (in the to-be-updated list) where the current and new trait values differ.
	
*/


	declare @taskName varchar(32)
	select @taskName = 'iCon.ItemImport'

	declare @itemListByTrait ItemListByTraitType
	declare @targetTraitID int
	declare @localeID int set @localeID = 1

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding Product Desc changes to item-update list...';
	/*
		Update [Product Description]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'Product Description'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'Product Description',
			il.[Product Description]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[Product Description] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[Product Description] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding POS Desc changes to item-update list...';
	/*
		Update [POS Description]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'POS Description'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'POS Description',
			il.[POS Description]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[POS Description] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[POS Description] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding Pkg Unit changes to item-update list...';
	/*
		Update [Package Unit]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'Package Unit'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'Package Unit',
			il.[Package Unit]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[Package Unit] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[Package Unit] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding Food Stamp changes to item-update list...';
	/*
		Update [Food Stamp Eligible]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'Food Stamp Eligible'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'Food Stamp Eligible',
			il.[Food Stamp Eligible]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[Food Stamp Eligible] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[Food Stamp Eligible] -- Only process entries where the current and new trait values differ.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding POS Scale Tare changes to item-update list...';
	/*
		Update [POS Scale Tare]
	*/
	select @targetTraitID = traitID from Trait where traitDesc = 'POS Scale Tare'
	insert into @itemListByTrait
		select
			sc.itemID,
			@targetTraitID,
			'POS Scale Tare',
			il.[POS Scale Tare]
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		join ItemTrait it (nolock)
			on sc.itemID = it.itemID -- Link to item trait instance.
			and it.traitID = @targetTraitID -- Link to specific trait name.
			and il.[POS Scale Tare] <> '' -- Ignore no-update entries.
			and isnull(it.traitValue,'') <> il.[POS Scale Tare] -- Only process entries where the current and new trait values differ.




	----------------------------------------------------------------------------
	----------------------------------------------------------------------------




	/*
		For item-hierarchy-class updates, we build a full list of target entries and pass that to an update procedure.
	*/

	declare
		@updateItemHierClassList ItemListByHierarchyClassType

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding brand hier changes to item-update list...';
	/*
		Add Brand Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Brand ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Brand ID] <> '' -- Ignore no-update entries.

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding browsing hier changes to item-update list...';
	/*
		Add Browsing Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Browsing Hierarchy ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Browsing Hierarchy ID] <> '' -- Ignore no-update entries.

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding merch hier changes to item-update list...';
	/*
		Add Merchandising Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Merchandising Hierarchy ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Merchandising Hierarchy ID] <> '' -- Ignore no-update entries.

	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Adding tax hier changes to item-update list...';
	/*
		Add Tax Hier Entries
	*/
	insert into @updateItemHierClassList
		select
			sc.itemID,
			il.[Tax Class ID],
			localeID = @localeID -- Not yet handling locale for items.
		from @itemList il
		join ScanCode sc (nolock) -- So we can pass itemID and save this lookup inside the update procedure.
			on il.ScanCode = sc.scanCode
		where
			il.[Tax Class ID] <> '' -- Ignore no-update entries.


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


-- All or nothing update.
begin tran
begin try


	----------------------------------------------------------------------------
	----------------------------------------------------------------------------


	declare @updatedItemIDs app.UpdatedItemIDsType


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Applying item-trait updates...';
	/*
	
		****** APPLY TRAIT UPDATES ******

	*/
	insert @updatedItemIDs
	exec app.UpdateItemListByTrait @itemListByTrait


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Applying item-hier updates...';
	/*
	
		****** APPLY HIERARCHY UPDATES ******

	*/
	insert @updatedItemIDs
	exec app.UpdateItemHierarchyClass @updateItemHierClassList


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Generating item update events...';
	/*

		****** GENERATING ITEM UPDATE EVENTS ******

	*/	
	exec app.GenerateItemUpdateEvents @updatedItemIDs


	print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Generating messages for ESB...';
	/*

		****** GENERATING MESSAGES FOR ESB ******

	*/	
	exec app.GenerateItemUpdateMessages @updatedItemIDs

	if @@TRANCOUNT > 0
	begin
		print '-------------------------------------------------';
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Committing ' + cast(@@TRANCOUNT as varchar) + ' transaction(s)...';
		COMMIT TRANSACTION
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Updates committed successfully.';
		print '-------------------------------------------------';
	end
	else
	begin
		PRINT '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + '**Warning** -- No updates to commit.';
	end
end try
begin catch
	IF @@TRANCOUNT > 0
	begin
		print '-------------------------------------------------';
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Performing transaction rollback...';
		ROLLBACK TRANSACTION
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + 'Rollback complete.';
		print '-------------------------------------------------';
	end
	else
	begin
		print '[' + convert(nvarchar, getdate(), 121) + '] ' + '[' + @taskName + '] ' + '**Nothing to rollback.';
	end

	DECLARE @ErrorMessage NVARCHAR(4000);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	SELECT
		@ErrorMessage = 'An error occurred.  Database changes were rolled back.
Tran count: ' + cast(@@TRANCOUNT as varchar) + '
Error: ''' + isnull(ERROR_MESSAGE(), '[no error msg]') + '''
Procedure: ' + isnull(ERROR_PROCEDURE(), '[no error procedure]') + '
Line: ' + cast(isnull(ERROR_LINE(), '[no error line]') as varchar)
		,@ErrorSeverity = ERROR_SEVERITY()
		,@ErrorState = ERROR_STATE()

	-- Rethrow error so caller gets message.
    RAISERROR (
		@ErrorMessage -- Message text.
		,@ErrorSeverity -- Severity.
		,@ErrorState -- State.
	)

end catch
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [app].[MessageException] WITH CHECK CHECK CONSTRAINT [FK_MessageException_MessageHistoryId];

ALTER TABLE [app].[MessageHistory] WITH CHECK CHECK CONSTRAINT [FK_MessageHistory_MessageStatus];

ALTER TABLE [app].[MessageHistory] WITH CHECK CHECK CONSTRAINT [FK_MessageHistory_MessageType];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageActionId];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageHistoryId];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageStatusId];

ALTER TABLE [app].[MessageQueueHierarchy] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueHierarchy_MessageTypeId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageTypeId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageStatusId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageHistoryId];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_IRMAPushID];

ALTER TABLE [app].[MessageQueueItemLocale] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueItemLocale_MessageActionId];

ALTER TABLE [app].[MessageQueueLocale] WITH CHECK CHECK CONSTRAINT [FK_app.MessageQueueLocale_MessageType];

ALTER TABLE [app].[MessageQueueLocale] WITH CHECK CHECK CONSTRAINT [FK_app.MessageQueueLocale_MessageStatus];

ALTER TABLE [app].[MessageQueueLocale] WITH CHECK CHECK CONSTRAINT [FK_app.MessageQueueLocale_MessageHistory];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_MessageTypeID];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_MessageStatusId];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_MessageHistoryId];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_IRMAPushID];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_UomCode];

ALTER TABLE [app].[MessageQueuePrice] WITH CHECK CHECK CONSTRAINT [FK_MessageQueuePrice_CurrencyCode];

ALTER TABLE [app].[MessageQueueProduct] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueProduct_MessageStatusId];

ALTER TABLE [app].[MessageQueueProduct] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueProduct_MessageTypeId];

ALTER TABLE [app].[MessageQueueProduct] WITH CHECK CHECK CONSTRAINT [FK_MessageQueueProduct_MessageHistoryId];


GO
PRINT N'Update complete.';


GO

-- end third script

-- Task 3343
UPDATE localetrait
SET traitid = (
		SELECT traitid
		FROM trait
		WHERE traitdesc = 'Region Abbreviation'
		)
WHERE traitid = 39

UPDATE localetrait
SET traitid = (
		SELECT traitid
		FROM trait
		WHERE traitdesc = 'PS Business Unit ID'
		)
WHERE traitid = 40

UPDATE localetrait
SET traitvalue = RIGHT(traitvalue, 5)
WHERE traitid = (
		SELECT traitid
		FROM trait
		WHERE traitdesc = 'PS Business Unit ID'
		)
	AND traitvalue LIKE 'BU_%'

-- end fourth script

SET IDENTITY_INSERT [dbo].[ItemPriceType] ON 
GO
INSERT [dbo].[ItemPriceType] ([itemPriceTypeID], [itemPriceTypeCode], [itemPriceTypeDesc]) VALUES (1, N'REG', N'Regular Price')
GO
INSERT [dbo].[ItemPriceType] ([itemPriceTypeID], [itemPriceTypeCode], [itemPriceTypeDesc]) VALUES (2, N'TPR', N'Temporary Price Reduction')
GO
SET IDENTITY_INSERT [dbo].[ItemPriceType] OFF
GO


INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (1, N'EA', N'EACH')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (2, N'LB', N'POUND')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (3, N'PH', N'BY COUNT')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (4, N'AV', N'CAPLETS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (5, N'CA', N'CASE')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (6, N'CT', N'COUNT')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (7, N'DZ', N'DOZENS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (8, N'FT', N'FEET')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (9, N'FO', N'FLUID OUNCES')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (10, N'GA', N'GALLONS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (11, N'GR', N'GRAMS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (12, N'IN', N'INCHES')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (13, N'KG', N'KILOGRAM')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (14, N'LT', N'LITERS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (15, N'MT', N'METERS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (16, N'ML', N'MILLILITERS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (17, N'MM', N'MILLIMETERS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (18, N'OZ', N'OUNCES')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (19, N'PT', N'PINTS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (20, N'QT', N'QUARTS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (21, N'SH', N'SHEETS')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (22, N'SZ', N'SIZE')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (23, N'U2', N'TABLET')
GO
INSERT [dbo].[UOM] ([uomID], [uomCode], [uomName]) VALUES (24, N'YD', N'YARDS')
GO

-- end fifth script

	-- task 3417
UPDATE trait
SET    traitdesc = 'Locked For Sale'
WHERE
   traitcode = 'RS'


   -- task	3416
UPDATE trait
SET    traitdesc = 'Authorized For Sale'
WHERE
   traitcode = 'NA' 

-- end sixth script

-- Task 3343
-- this should be done after the udm 3.0 upgrade
/****** Add applications to the App table ******/

DECLARE @WebApp NVARCHAR(255)
DECLARE @InterfaceController NVARCHAR(255)
DECLARE @EmsListenerService NVARCHAR(255)
DECLARE @IconService NVARCHAR(255)
DECLARE @ApiController NVARCHAR(255)

SET  @WebApp = 'Web App'
SET  @InterfaceController = 'Interface Controller'
SET  @EmsListenerService = 'Ems Listener Service'
SET  @IconService = 'Icon Service'
SET  @ApiController = 'API Controller'

IF (NOT EXISTS (SELECT [AppName] FROM [Icon].[app].[App] WHERE [AppName] = @WebApp))
BEGIN
	INSERT INTO [Icon].[app].[App] ([AppName])
	VALUES (@WebApp)
END

IF (NOT EXISTS (SELECT [AppName] FROM [Icon].[app].[App] WHERE [AppName] = @InterfaceController))
BEGIN
	INSERT INTO [Icon].[app].[App] ([AppName])
	VALUES (@InterfaceController)
END

IF (NOT EXISTS (SELECT [AppName] FROM [Icon].[app].[App] WHERE [AppName] = @EmsListenerService))
BEGIN
	INSERT INTO [Icon].[app].[App] ([AppName])
	VALUES (@EmsListenerService)
END

IF (NOT EXISTS (SELECT [AppName] FROM [Icon].[app].[App] WHERE [AppName] = @IconService))
BEGIN
	INSERT INTO [Icon].[app].[App] ([AppName])
	VALUES (@IconService)
END

IF (NOT EXISTS (SELECT [AppName] FROM [Icon].[app].[App] WHERE [AppName] = @ApiController))
BEGIN
	INSERT INTO [Icon].[app].[App] ([AppName])
	VALUES (@ApiController)
END

SET IDENTITY_INSERT [app].[EventType] ON 

GO
INSERT [app].[EventType] ([EventId], [EventName]) VALUES (1, N'New IRMA Item')
GO
INSERT [app].[EventType] ([EventId], [EventName]) VALUES (2, N'Item Update')
GO
INSERT [app].[EventType] ([EventId], [EventName]) VALUES (3, N'Item Validation')
GO
INSERT [app].[EventType] ([EventId], [EventName]) VALUES (4, N'Brand Name Update')
GO
INSERT [app].[EventType] ([EventId], [EventName]) VALUES (5, N'Tax Name Update')
GO
INSERT [app].[EventType] ([EventId], [EventName]) VALUES (6, N'New Tax Hierarchy')
GO
SET IDENTITY_INSERT [app].[EventType] OFF
GO
SET IDENTITY_INSERT [app].[MessageAction] ON 

GO
INSERT [app].[MessageAction] ([MessageActionId], [MessageActionName]) VALUES (1, N'AddOrUpdate')
GO
INSERT [app].[MessageAction] ([MessageActionId], [MessageActionName]) VALUES (2, N'Delete')
GO
SET IDENTITY_INSERT [app].[MessageAction] OFF
GO
SET IDENTITY_INSERT [app].[MessageStatus] ON 

GO
INSERT [app].[MessageStatus] ([MessageStatusId], [MessageStatusName]) VALUES (1, N'Ready')
GO
INSERT [app].[MessageStatus] ([MessageStatusId], [MessageStatusName]) VALUES (2, N'Sent')
GO
INSERT [app].[MessageStatus] ([MessageStatusId], [MessageStatusName]) VALUES (3, N'Failed')
GO
INSERT [app].[MessageStatus] ([MessageStatusId], [MessageStatusName]) VALUES (5, N'Associated')
GO
SET IDENTITY_INSERT [app].[MessageStatus] OFF
GO
SET IDENTITY_INSERT [app].[MessageType] ON 

GO
INSERT [app].[MessageType] ([MessageTypeId], [MessageTypeName]) VALUES (1, N'Locale')
GO
INSERT [app].[MessageType] ([MessageTypeId], [MessageTypeName]) VALUES (2, N'Hierarchy')
GO
INSERT [app].[MessageType] ([MessageTypeId], [MessageTypeName]) VALUES (3, N'Item Locale')
GO
INSERT [app].[MessageType] ([MessageTypeId], [MessageTypeName]) VALUES (4, N'Price')
GO
INSERT [app].[MessageType] ([MessageTypeId], [MessageTypeName]) VALUES (5, N'Department Sale')
GO
INSERT [app].[MessageType] ([MessageTypeId], [MessageTypeName]) VALUES (6, N'Product')
GO
INSERT [app].[MessageType] ([MessageTypeId], [MessageTypeName]) VALUES (7, N'Item Status')
GO
SET IDENTITY_INSERT [app].[MessageType] OFF
GO

-- end seventh script

-- 
DELETE
FROM HierarchyPrototype
WHERE HIERARCHYID = 1
INSERT INTO HierarchyPrototype (
	HIERARCHYID,
	hierarchyLevel,
	hierarchyLevelName,
	itemsAttached
	)
VALUES (
	1,
	1,
	'Segment',
	1
	)
INSERT INTO HierarchyPrototype (
	HIERARCHYID,
	hierarchyLevel,
	hierarchyLevelName,
	itemsAttached
	)
VALUES (
	1,
	2,
	'Family',
	1
	)
INSERT INTO HierarchyPrototype (
	HIERARCHYID,
	hierarchyLevel,
	hierarchyLevelName,
	itemsAttached
	)
VALUES (
	1,
	3,
	'Class',
	1
	)
INSERT INTO HierarchyPrototype (
	HIERARCHYID,
	hierarchyLevel,
	hierarchyLevelName,
	itemsAttached
	)
VALUES (
	1,
	4,
	'GS1 Brick',
	1
	)
INSERT INTO HierarchyPrototype (
	HIERARCHYID,
	hierarchyLevel,
	hierarchyLevelName,
	itemsAttached
	)
VALUES (
	1,
	5,
	'Sub Brick',
	1
	)
CREATE TABLE ##GS1Temp (
	[Segment Code] NVARCHAR(255),
	[Segment Description] NVARCHAR(255),
	[Family Code] NVARCHAR(255),
	[Family Description] NVARCHAR(255),
	[Class Code] NVARCHAR(255),
	[Class Description] NVARCHAR(255),
	[GS1 Brick Code] NVARCHAR(255),
	[GS1 Brick Description] NVARCHAR(255),
	[Sub Brick Code] NVARCHAR(255),
	[Sub Brick Description] NVARCHAR(255)
	);
BULK INSERT ##GS1Temp
FROM '\\irmadevfile\e$\icondata\WFMMerchHier.txt' WITH (FirstRow = 2)
DECLARE @SegmentTemp TABLE (
	hierarchyClassName VARCHAR(255),
	hierarchyLevel INT,
	HIERARCHYID INT,
	gsID VARCHAR(255),
	hierarchyParentClassID INT
	)
DECLARE @SegmentOutputTemp TABLE (
	hierarchyClassID INT,
	gsID VARCHAR(255),
	hierarchyClassName VARCHAR(255)
	)
DECLARE @FamilyTemp TABLE (
	hierarchyClassName VARCHAR(255),
	hierarchyLevel INT,
	HIERARCHYID INT,
	gsID VARCHAR(255),
	hierarchyParentClassID INT
	)
DECLARE @FamilyOutputTemp TABLE (
	hierarchyClassID INT,
	gsID VARCHAR(255),
	hierarchyClassName VARCHAR(255)
	)
DECLARE @ClassTemp TABLE (
	hierarchyClassName VARCHAR(255),
	hierarchyLevel INT,
	HIERARCHYID INT,
	gsID VARCHAR(255),
	hierarchyParentClassID INT
	)
DECLARE @ClassOutputTemp TABLE (
	hierarchyClassID INT,
	gsID VARCHAR(255),
	hierarchyClassName VARCHAR(255)
	)
DECLARE @BrickTemp TABLE (
	hierarchyClassName VARCHAR(255),
	hierarchyLevel INT,
	HIERARCHYID INT,
	gsID VARCHAR(255),
	hierarchyParentClassID INT
	)
DECLARE @BrickOutputTemp TABLE (
	hierarchyClassID INT,
	gsID VARCHAR(255),
	hierarchyClassName VARCHAR(255)
	)
DECLARE @SubBrickTemp TABLE (
	hierarchyClassName VARCHAR(255),
	hierarchyLevel INT,
	HIERARCHYID INT,
	gsID VARCHAR(255),
	hierarchyParentClassID INT
	)
DECLARE @SubBrickOutputTemp TABLE (
	hierarchyClassID INT,
	gsID VARCHAR(255),
	hierarchyClassName VARCHAR(255)
	)
INSERT INTO @SegmentTemp
SELECT hierarchyClassName,
	hierarchyLevel,
	HIERARCHYID,
	gsID,
	hierarchyParentClassID
FROM (
	SELECT DISTINCT [Segment Description] AS hierarchyClassName,
		1 AS hierarchyLevel,
		1 AS HIERARCHYID,
		[Segment Code] AS gsID,
		NULL AS hierarchyParentClassID
	FROM ##GS1Temp gs1
	WHERE [Segment Description] IS NOT NULL
	) segment
MERGE INTO HierarchyClass
USING @SegmentTemp AS st
	ON 1 = 0
WHEN NOT MATCHED
	THEN
		INSERT (
			hierarchyLevel,
			HIERARCHYID,
			hierarchyParentClassID,
			hierarchyClassName
			)
		VALUES (
			1,
			1,
			NULL,
			st.hierarchyClassName
			)
OUTPUT inserted.hierarchyClassID,
	st.gsID,
	st.hierarchyClassName
INTO @SegmentOutputTemp(hierarchyClassID, gsID, hierarchyClassName);--Setting up @FamilyTemp table 
INSERT INTO @FamilyTemp
SELECT hierarchyClassName,
	hierarchyLevel,
	HIERARCHYID,
	gsID,
	hierarchyParentClassID
FROM (
	SELECT DISTINCT [Family Description] AS hierarchyClassName,
		2 AS hierarchyLevel,
		1 AS HIERARCHYID,
		[Family Code] AS gsID,
		st.hierarchyClassID AS hierarchyParentClassID
	FROM ##GS1Temp gs1
	INNER JOIN @SegmentOutputTemp st ON st.gsID = gs1.[Segment Code]
	) family
MERGE INTO HierarchyClass
USING @FamilyTemp AS ft
	ON 1 = 0
WHEN NOT MATCHED
	THEN
		INSERT (
			hierarchyLevel,
			HIERARCHYID,
			hierarchyParentClassID,
			hierarchyClassName
			)
		VALUES (
			2,
			1,
			ft.hierarchyParentClassID,
			ft.hierarchyClassName
			)
OUTPUT inserted.hierarchyClassID,
	ft.gsID,
	ft.hierarchyClassName
INTO @FamilyOutputTemp(hierarchyClassID, gsID, hierarchyClassName);--Setting up @ClassTemp table 
INSERT INTO @ClassTemp
SELECT hierarchyClassName,
	hierarchyLevel,
	HIERARCHYID,
	gsID,
	hierarchyParentClassID
FROM (
	SELECT DISTINCT [Class Description] AS hierarchyClassName,
		2 AS hierarchyLevel,
		1 AS HIERARCHYID,
		[Class Code] AS gsID,
		ft.hierarchyClassID AS hierarchyParentClassID
	FROM ##GS1Temp gs1
	INNER JOIN @FamilyOutputTemp ft ON ft.gsID = gs1.[Family Code]
	) class
MERGE INTO HierarchyClass
USING @ClassTemp AS ct
	ON 1 = 0
WHEN NOT MATCHED
	THEN
		INSERT (
			hierarchyLevel,
			HIERARCHYID,
			hierarchyParentClassID,
			hierarchyClassName
			)
		VALUES (
			3,
			1,
			ct.hierarchyParentClassID,
			ct.hierarchyClassName
			)
OUTPUT inserted.hierarchyClassID,
	ct.gsID,
	ct.hierarchyClassName
INTO @ClassOutputTemp(hierarchyClassID, gsID, hierarchyClassName);--Setting up @BrickTemp table 
INSERT INTO @BrickTemp
SELECT hierarchyClassName,
	hierarchyLevel,
	HIERARCHYID,
	gsID,
	hierarchyParentClassID
FROM (
	SELECT DISTINCT [GS1 Brick Description] AS hierarchyClassName,
		2 AS hierarchyLevel,
		1 AS HIERARCHYID,
		[GS1 Brick Code] AS gsID,
		ct.hierarchyClassID AS hierarchyParentClassID
	FROM ##GS1Temp gs1
	INNER JOIN @ClassOutputTemp ct ON ct.gsID = gs1.[Class Code]
	) brick 

MERGE INTO HierarchyClass
USING @BrickTemp AS bt
	ON 1 = 0
WHEN NOT MATCHED
	THEN
		INSERT (
			hierarchyLevel,
			HIERARCHYID,
			hierarchyParentClassID,
			hierarchyClassName
			)
		VALUES (
			4,
			1,
			bt.hierarchyParentClassID,
			bt.hierarchyClassName
			)
OUTPUT inserted.hierarchyClassID,
	bt.gsID,
	bt.hierarchyClassName
INTO @BrickOutputTemp(hierarchyClassID, gsID, hierarchyClassName);--Setting up @AttributeTemp table 
INSERT INTO @SubBrickTemp
SELECT hierarchyClassName,
	hierarchyLevel,
	HIERARCHYID,
	gsID,
	hierarchyParentClassID
FROM (
	SELECT DISTINCT [Sub Brick Description] AS hierarchyClassName,
		5 AS hierarchyLevel,
		1 AS HIERARCHYID,
		[Sub Brick Code] AS gsID,
		bt.hierarchyClassID AS hierarchyParentClassID
	FROM ##GS1Temp gs1
	INNER JOIN @BrickOutputTemp bt ON bt.gsID = gs1.[GS1 Brick Code]
		AND gs1.[Sub Brick Code] IS NOT NULL
	) attribute 

MERGE INTO HierarchyClass
USING @SubBrickTemp AS at
	ON 1 = 0
WHEN NOT MATCHED
	THEN
		INSERT (
			hierarchyLevel,
			HIERARCHYID,
			hierarchyParentClassID,
			hierarchyClassName
			)
		VALUES (
			5,
			1,
			at.hierarchyParentClassID,
			at.hierarchyClassName
			)
OUTPUT inserted.hierarchyClassID,
	at.gsID,
	at.hierarchyClassName
INTO @SubBrickOutputTemp(hierarchyClassID, gsID, hierarchyClassName);

INSERT INTO hierarchyclasstrait (
	traitid,
	hierarchyclassid,
	traitvalue
	)
SELECT t.traitid,
	sb.hierarchyclassid,
	sb.gsID
FROM @SubBrickOutputTemp sb
CROSS JOIN (
	SELECT traitid
	FROM trait
	WHERE traitcode = 'SBC'
	) t

SELECT *
FROM @SubBrickOutputTemp

DROP TABLE ##GS1Temp 
GO

SELECT *
FROM HierarchyClass
WHERE HIERARCHYID = 1
ORDER BY hierarchyClassName,
	hierarchyClassID,
	hierarchyLevel

SELECT *
FROM HierarchyClassTrait

-- end first hierarchy load

SET IDENTITY_INSERT [dbo].[Hierarchy] ON;
INSERT INTO Hierarchy (
	HIERARCHYID,
	hierarchyName
	)
VALUES (
	'5',
	'Financial'
	)
SET IDENTITY_INSERT [dbo].[Hierarchy] OFF;

CREATE TABLE #FinTemp (
	hier NVARCHAR(255),
	code NVARCHAR(255)
	);
BULK INSERT #FinTemp
FROM '\\irmadevfile\e$\ICONData\FinancialHierarchy.txt'

DECLARE @ID INT
SELECT @ID = HIERARCHYID
FROM Hierarchy
WHERE hierarchyName = 'Financial'
PRINT @id
INSERT INTO hierarchyprototype (
	HIERARCHYID,
	hierarchylevel,
	hierarchylevelname,
	itemsattached
	)
VALUES (
	@ID,
	1,
	'Financial',
	1
	)
-----------------------------------------------
DECLARE @SegmentOutputTemp TABLE (
	hierarchyClassID INT,
	hier NVARCHAR(255),
	code NVARCHAR(255)
	)
MERGE INTO HierarchyClass
USING #FinTemp AS st
	ON 1 = 0
WHEN NOT MATCHED
	THEN
		INSERT (
			hierarchyLevel,
			HIERARCHYID,
			hierarchyClassName
			)
		VALUES (
			1,
			@ID,
			--	NULL,
			st.hier
			)
OUTPUT inserted.hierarchyClassID,
	st.code,
	st.hier
INTO @SegmentOutputTemp(hierarchyClassID, code, hier);
INSERT INTO hierarchyclasstrait (
	traitid,
	hierarchyclassid,
	traitvalue
	)
SELECT t.traitid,
	sb.hierarchyclassid,
	sb.code
FROM @SegmentOutputTemp sb
CROSS JOIN (
	SELECT traitid
	FROM trait
	WHERE traitcode = 'FIN'
	) t
SELECT *
FROM @SegmentOutputTemp
DROP TABLE #FinTemp
SELECT *
FROM hierarchyclass
WHERE HIERARCHYID = @ID


select * from Hierarchy

-- end second hierarchy load

CREATE TABLE ##MerchAndFinTemp (
	[Sub Brick Code] NVARCHAR(255),
	[Sub Brick Description] NVARCHAR(255),
	[Financial Hierarchy Code] NVARCHAR(255),
	[Financial Hierarchy Description] NVARCHAR(255)
	);
BULK INSERT ##MerchAndFinTemp
FROM '\\irmadevfile\e$\icondata\MerchAndFin.txt' WITH (FirstRow = 2)

INSERT INTO hierarchyclasstrait (
	traitid,
	hierarchyclassid,
	traitvalue
	)
SELECT (SELECT traitid FROM trait WHERE traitcode = 'MFM') as traitid,
	sbc.hierarchyclassid,
	mfm.[Financial Hierarchy Description] AS traitvalue
FROM ##MerchAndFinTemp mfm
INNER JOIN HierarchyClassTrait sbc ON sbc.traitvalue = mfm.[Sub Brick Code]
INNER JOIN trait t ON sbc.traitid = t.traitid
	AND t.traitCode = 'SBC'
DROP TABLE ##MerchAndFinTemp
SELECT *
FROM HierarchyClasstrait hct
INNER JOIN trait t ON t.traitid = hct.traitid
	AND t.traitcode = 'MFM'

-- end third hierarchy load

-- Should be run on UDM 3.0 (or after HCT table is present)
-- Load Flat File
IF object_id('dbo.#CCHTemp') IS NOT NULL
	DROP TABLE #CCHTemp
CREATE TABLE #CCHTemp (
	taxclassabbrev NVARCHAR(255),
	taxclasslong NVARCHAR(255)
	);
BULK INSERT #CCHTemp
FROM '\\irmadevfile\e$\ICONData\CCHTax.txt' WITH (FirstRow = 2)

-- Show 'Before' 
SELECT * INTO #TaxClassBefore
FROM #CCHTemp foo
LEFT JOIN ( SELECT * FROM hierarchyclass WHERE HIERARCHYID = 3 ) bar 
ON LEFT(foo.taxclasslong, 7) = LEFT(bar.hierarchyClassName, 7)

SELECT * FROM #TaxClassBefore

-- Begin Merge
MERGE INTO hierarchyclass hc
USING #CCHTemp tax
	ON LEFT(tax.taxclasslong, 7) = LEFT(hc.hierarchyClassName, 7)
WHEN MATCHED THEN
		UPDATE SET hierarchyclassname = tax.taxclasslong
WHEN NOT MATCHED THEN
		INSERT ( hierarchylevel, HIERARCHYID, hierarchyclassname )
		VALUES ( 1, 3, tax.taxclasslong );

-- Show 'After'
SELECT * INTO #TaxClassAfter FROM #CCHTemp foo
LEFT JOIN ( SELECT * FROM hierarchyclass WHERE HIERARCHYID = 3 ) bar 
ON LEFT(foo.taxclasslong, 7) = LEFT(bar.hierarchyClassName, 7)

SELECT * FROM #TaxClassAfter

---- Put Tax Class Abbreviations into HCT 
MERGE INTO hierarchyclasstrait hct
USING #TaxClassAfter tca
ON tca.hierarchyclassid = hct.hierarchyclassid and hct.traitid = (select traitid from trait where traitcode='ABR')
WHEN MATCHED THEN
UPDATE SET hct.traitvalue = tca.taxclassabbrev
WHEN NOT MATCHED THEN
   INSERT (traitid, hierarchyClassID, traitValue)
   VALUES ((select traitid from trait where traitcode='ABR'), tca.hierarchyclassid, tca.taxclassabbrev);

-- Select HC and HCT to check our work
SELECT * 
FROM HierarchyClass hc
JOIN HierarchyClassTrait hct on hc.hierarchyClassID = hct.hierarchyClassID
WHERE hc.hierarchyID = 3

-- Clean Up
DROP TABLE #CCHTemp, #TaxClassBefore, #TaxClassAfter

-- end fourth hierarchy load