 /****** Object:  StoredProcedure [dbo].[CancelAllSales]    Script Date: 5/22/2007 11:06:56 ******/
IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[dbo].[CancelAllSales]') AND OBJECTPROPERTY(id,N'IsProcedure') = 1)
DROP PROCEDURE [dbo].[CancelAllSales]
GO

--CANCEL ALL SALES FOR THE ITEM KEY AND LIST OF STORES PASSED IN
CREATE PROCEDURE [dbo].[CancelAllSales]
	@Item_Key int,
	@StoreList varchar(8000),
    @StoreListSeparator char(1),
    @StartDate smalldatetime,  --EFFECTIVE DATE OF CANCELLATION
    @User_ID int,
    @User_ID_Date datetime,
    @ValidationCode int OUTPUT
AS
BEGIN
    SET NOCOUNT ON

	DECLARE @error_no int
    SET @error_no = 0
    
    DECLARE @StoreTable table(Store_no int)
	
	--BUILD STORE TABLE FROM PIPE DELIMITED LIST PASSED IN
	INSERT INTO @StoreTable
		SELECT Key_Value FROM dbo.fn_Parse_List(@StoreList, @StoreListSeparator) StoreList
    
	--[STEPS TAKEN FROM TECH SPEC FOR 'END SALE EARLY AND CANCEL ALL SALES' DOCUMENTATION]

	--STEP 1
	--1.	If there are PriceBatchDetail records for the Store/Item with a “Sale” PriceChgTypeID 
	--      assigned to a batch header record and the batch header record is in the Building state, 
	--      the PriceBatchDetail records will be removed from the batch by setting the PriceBatchHeaderID 
	--      in the PriceBatchDetail table to NULL.
	BEGIN
		UPDATE PriceBatchDetail SET PriceBatchHeaderID = NULL
		WHERE PriceBatchDetailID IN (
			SELECT PBD.PriceBatchDetailID
			FROM PriceBatchDetail PBD
			INNER JOIN Item I (nolock)
				ON PBD.Item_Key = I.Item_Key
			INNER JOIN @StoreTable S 
				ON PBD.Store_No = S.Store_No	
			INNER JOIN PriceChgType PCT (nolock)
				ON PCT.PriceChgTypeID = PBD.PriceChgTypeID
			INNER JOIN PriceBatchHeader PBH (nolock)
				ON PBH.PriceBatchHeaderID = PBD.PriceBatchHeaderID
			WHERE I.Item_Key = @Item_Key 
				AND PCT.On_Sale = 1 --SALE BATCH	
				AND PBD.PriceBatchHeaderID IS NOT NULL --ASSIGNED TO A BATCH
				AND PBH.PriceBatchStatusID = 1
				AND Expired <> 1)

		SELECT @error_no = @@ERROR
	END

	--STEP 2
	--2.	All PriceBatchDetail records for the Store/Item with a “Sale” PriceChgTypeID will be set to Expired.  
	--      This includes records that have already been batched and sent to the POS, as well as future price changes that 
	--      are pending in the database.
	IF @error_no = 0
    BEGIN 
		--HANDLE ITEMS THAT HAVE BEEN BATCHED IN SOME STATUS
		UPDATE PriceBatchDetail SET Expired = 1, EndedEarly = 1
		WHERE PriceBatchDetailID IN (
			SELECT PBD.PriceBatchDetailID
			FROM PriceBatchDetail PBD
			INNER JOIN Item I (nolock)
				ON PBD.Item_Key = I.Item_Key
			INNER JOIN @StoreTable S 
				ON PBD.Store_No = S.Store_No	
			INNER JOIN PriceChgType PCT (nolock)
				ON PCT.PriceChgTypeID = PBD.PriceChgTypeID
			INNER JOIN PriceBatchHeader PBH (nolock)
				ON PBH.PriceBatchHeaderID = PBD.PriceBatchHeaderID
			WHERE I.Item_Key = @Item_Key
				AND PCT.On_Sale = 1 --SALE BATCH	
				AND Expired <> 1 --NOT YET EXPIRED
				AND PBD.PriceBatchHeaderID IS NOT NULL --ASSIGNED TO A BATCH	
				AND 
					--BATCH NOT YET PROCESSED (STEP 2 CLEANS UP THOSE IN 'BUILDING' STATUS)
					(PBH.PriceBatchStatusID IN (2,3,4,5) 
						OR 
					--BATCH HAS BEEN PROCESSED AND SALE NOT YET OVER
					(PBH.PriceBatchStatusID = 6 AND PBD.Sale_End_Date > @StartDate) )) 
		
		SELECT @error_no = @@ERROR
	END

	IF @error_no = 0
    BEGIN
		--EXPIRE ALL PRICE CHANGE RECORDS THAT HAVE NOT YET BEEN BATCHED 
		-- INCLUDE ANY AUTO-GENERATED REGs, SINCE THOSE WILL BE REPLACED WITH THE CANCEL REG
		UPDATE PriceBatchDetail SET Expired = 1, EndedEarly = 1
		WHERE PriceBatchDetailID IN (
			SELECT PBD.PriceBatchDetailID
			FROM PriceBatchDetail PBD
			INNER JOIN Item I (nolock)
				ON PBD.Item_Key = I.Item_Key
			INNER JOIN @StoreTable S 
				ON PBD.Store_No = S.Store_No	
			WHERE I.Item_Key = @Item_Key
				AND PBD.PriceChgTypeID IS NOT NULL --PRICE CHANGES ONLY
				AND PBD.PriceBatchHeaderID IS NULL --NOT YET IN A BATCH
				AND PBD.StartDate >= @StartDate	   --PENDING RECORD WILL BE AFFECTED BY SALE CANCELLATION STARTDATE
				AND Expired <> 1
				AND (dbo.fn_OnSale(PBD.PriceChgTypeId) = 1
					OR PBD.AutoGenerated = 1)
				)
		
		SELECT @error_no = @@ERROR
	END
	
	--STEP 3
	--3.	A new PriceBatchDetail record will be generated to send down a “REG” price change, with the start date equal to the 
	--      cancel date specified by the user, to end the ongoing sale for the item.  	
	IF @error_no = 0
    BEGIN
		DECLARE @CurrentStoreNo int
		DECLARE @Price smallmoney
		DECLARE @POSPrice smallmoney
		DECLARE @Multiple tinyint
		
		--CREATE A CURSOR TO STEP THROUGH EACH STORE IN THE STORE LIST
		-- only for stores that are actually on sale!  Otherwise, no need to insert a new REG price.  
		DECLARE csStores CURSOR
		READ_ONLY
		FOR     
			SELECT ST.Store_No
			FROM @StoreTable ST
			INNER JOIN PRICE P
				ON P.Store_No = ST.Store_No
				AND P.Item_Key = @Item_Key
			WHERE dbo.fn_OnSale(P.PriceChgTypeID) = 1 		
		
		OPEN csStores
	    
		FETCH NEXT FROM csStores INTO @CurrentStoreNo
		WHILE (@@fetch_status <> -1)
		BEGIN
    		IF (@@fetch_status <> -2)
		BEGIN
			--GET THE CURRENT PRICE & MULTIPLE FROM THE PRICE TABLE FOR THIS ITEM
			SELECT @Price = Price, @POSPrice = POSPrice, @Multiple = Multiple 
			FROM Price 
			WHERE Item_Key = @Item_Key 
				AND Store_No = @CurrentStoreNo
	    
	    			-- DON'T INSERT THE CANCEL REG IF THERE'S ALREADY A USER-ENTERED REG CHANGE THERE
			IF NOT EXISTS (SELECT 1 
					FROM PriceBatchDetail 
					WHERE Item_Key = @Item_Key 
					AND Store_No = @CurrentStoreNo
					AND dbo.fn_OnSale(PriceChgTypeId) = 0
					AND AutoGenerated = 0
					AND StartDate = @StartDate
					AND Expired = 0)
				BEGIN
					--INSERT NEW REG PRICE FOR THIS STORE/ITEM
					EXEC UpdatePriceBatchDetailReg @Item_Key, @User_ID, @User_ID_Date, @CurrentStoreNo, @StartDate, 
										   @Multiple, @POSPrice, @Price, NULL, 'IRMA Client', @ValidationCode, 1
				END
		END
    		FETCH NEXT FROM csStores INTO @CurrentStoreNo
		END
	    
		CLOSE csStores
		DEALLOCATE csStores		
   		
		SELECT @error_no = @@ERROR
	END	
	
	--STEP 4
	--4.	When the POS Push process applies the “REG” price change to the Price table, it should change the Sale End Date for 
	--      the ongoing sale to the day before the Start Date of the “REG” price change.
		
	--THIS STEP HANDLED BY POS PROCESS IN THE Replenishment_POSPush_UpdatePriceBatchProcessedChg STORED PROCEDURE
    
    IF @error_no <> 0
    BEGIN
        IF @@TRANCOUNT <> 0
            ROLLBACK TRAN
        DECLARE @Severity smallint
        SELECT @Severity = ISNULL((SELECT severity FROM master.dbo.sysmessages WHERE error = @error_no), 16)
        RAISERROR ('CancelAllSales failed with @@ERROR: %d', @Severity, 1, @error_no)
    END    
    
    SET NOCOUNT OFF
END
GO
   