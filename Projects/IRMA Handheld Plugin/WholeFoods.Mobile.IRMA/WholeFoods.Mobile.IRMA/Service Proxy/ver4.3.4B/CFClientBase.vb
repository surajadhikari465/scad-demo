'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'     Runtime Version:2.0.50727.5448
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On


Namespace Microsoft.Tools.ServiceModel
    
    <System.Diagnostics.DebuggerStepThroughAttribute(),  _
     System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Tools.ServiceModel.NetCFSvcUtil", "3.5.0.0")>  _
    Public Class CFClientBase(Of TChannel As  class)
        
        Private binding As System.ServiceModel.Channels.Binding
        
        Private oneWayBinding As System.ServiceModel.Channels.CustomBinding
        
        Private _requestChannelFactory As System.ServiceModel.Channels.IChannelFactory(Of System.ServiceModel.Channels.IRequestChannel)
        
        Private _outputChannelFactory As System.ServiceModel.Channels.IChannelFactory(Of System.ServiceModel.Channels.IOutputChannel)
        
        Private _clientCredentials As System.ServiceModel.Description.ClientCredentials
        
        Private remoteAddress As System.ServiceModel.EndpointAddress
        
        Private _parameters As System.ServiceModel.Channels.BindingParameterCollection
        
        Private requestChannelFactorySyncObject As Object
        
        Private outputChannelFactorySyncObject As Object
        
        Private serializers As System.Collections.Generic.Dictionary(Of CFContractSerializerInfo, System.Runtime.Serialization.XmlObjectSerializer) = New System.Collections.Generic.Dictionary(Of CFContractSerializerInfo, System.Runtime.Serialization.XmlObjectSerializer)(2)
        
        Public Sub New(ByVal binding As System.ServiceModel.Channels.Binding, ByVal remoteAddress As System.ServiceModel.EndpointAddress)
            MyBase.New
            If (binding Is Nothing) Then
                Throw New System.ArgumentNullException("binding")
            End If
            If (remoteAddress Is Nothing) Then
                Throw New System.ArgumentNullException("remoteAddress")
            End If
            Me.remoteAddress = remoteAddress
            Me.binding = binding
            Me._clientCredentials = New System.ServiceModel.Description.ClientCredentials
            Me._parameters = New System.ServiceModel.Channels.BindingParameterCollection
            Me._parameters.Add(Me._clientCredentials)
            Me.outputChannelFactorySyncObject = New Object
            Me.requestChannelFactorySyncObject = New Object
        End Sub
        
        Public ReadOnly Property ClientCredentials() As System.ServiceModel.Description.ClientCredentials
            Get
                Return Me._clientCredentials
            End Get
        End Property
        
        Protected ReadOnly Property Parameters() As System.ServiceModel.Channels.BindingParameterCollection
            Get
                Return Me._parameters
            End Get
        End Property
        
        Private ReadOnly Property OutputChannelFactory() As System.ServiceModel.Channels.IChannelFactory(Of System.ServiceModel.Channels.IOutputChannel)
            Get
                If (Me._outputChannelFactory Is Nothing) Then
                    System.Threading.Monitor.Enter(Me.outputChannelFactorySyncObject)
                    Try 
                        If (Me._outputChannelFactory Is Nothing) Then
                            If (Me.oneWayBinding Is Nothing) Then
                                Me.oneWayBinding = New System.ServiceModel.Channels.CustomBinding(Me.binding)
                            End If
                            If Me.oneWayBinding.CanBuildChannelFactory(Of System.ServiceModel.Channels.IOutputChannel)(Me.Parameters) Then
                                Me._outputChannelFactory = Me.oneWayBinding.BuildChannelFactory(Of System.ServiceModel.Channels.IOutputChannel)(Me.Parameters)
                                Me._outputChannelFactory.Open
                            End If
                        End If
                    Finally
                        System.Threading.Monitor.Exit(Me.outputChannelFactorySyncObject)
                    End Try
                End If
                Return Me._outputChannelFactory
            End Get
        End Property
        
        Private ReadOnly Property RequestChannelFactory() As System.ServiceModel.Channels.IChannelFactory(Of System.ServiceModel.Channels.IRequestChannel)
            Get
                If (Me._requestChannelFactory Is Nothing) Then
                    System.Threading.Monitor.Enter(Me.requestChannelFactorySyncObject)
                    Try 
                        If (Me._requestChannelFactory Is Nothing) Then
                            If Me.binding.CanBuildChannelFactory(Of System.ServiceModel.Channels.IRequestChannel)(Me.Parameters) Then
                                Me._requestChannelFactory = Me.binding.BuildChannelFactory(Of System.ServiceModel.Channels.IRequestChannel)(Me.Parameters)
                                Me._requestChannelFactory.Open
                            End If
                        End If
                    Finally
                        System.Threading.Monitor.Exit(Me.requestChannelFactorySyncObject)
                    End Try
                End If
                Return Me._requestChannelFactory
            End Get
        End Property
        
        Protected Shared Sub ApplyProtection(ByVal action As String, ByVal parts As System.ServiceModel.Security.ScopedMessagePartSpecification, ByVal protection As Boolean)
            Dim partSpec As System.ServiceModel.Security.MessagePartSpecification
            If protection Then
                partSpec = New System.ServiceModel.Security.MessagePartSpecification(true)
            Else
                partSpec = System.ServiceModel.Security.MessagePartSpecification.NoParts
            End If
            parts.AddParts(partSpec, action)
        End Sub
        
        Protected Shared Function IsSecureMessageBinding(ByVal binding As System.ServiceModel.Channels.Binding) As Boolean
            If GetType(System.ServiceModel.BasicHttpBinding).IsInstanceOfType(binding) Then
                Return false
            End If
            If GetType(System.ServiceModel.Channels.CustomBinding).IsInstanceOfType(binding) Then
                Return CType(binding,System.ServiceModel.Channels.CustomBinding).Elements.Contains(GetType(System.ServiceModel.Channels.AsymmetricSecurityBindingElement))
            End If
            Throw New System.NotSupportedException("Unsupported binding type.")
        End Function
        
        Protected Sub Close()
            If (Not (Me.RequestChannelFactory) Is Nothing) Then
                System.Threading.Monitor.Enter(Me.RequestChannelFactory)
                Try 
                    Me.RequestChannelFactory.Close
                Finally
                    System.Threading.Monitor.Exit(Me.RequestChannelFactory)
                End Try
            End If
            If (Not (Me.OutputChannelFactory) Is Nothing) Then
                System.Threading.Monitor.Enter(Me.OutputChannelFactory)
                Try 
                    Me.OutputChannelFactory.Close
                Finally
                    System.Threading.Monitor.Exit(Me.OutputChannelFactory)
                End Try
            End If
        End Sub
        
        Protected Overloads Function Invoke(Of TREQUEST, TRESPONSE)(ByVal info As CFInvokeInfo, ByVal request As TREQUEST) As TRESPONSE
            Dim serializerInfo As CFContractSerializerInfo = New CFContractSerializerInfo
            serializerInfo.MessageContractType = GetType(TREQUEST)
            serializerInfo.IsWrapped = info.RequestIsWrapped
            serializerInfo.ExtraTypes = info.ExtraTypes
            serializerInfo.UseEncoded = info.UseEncoded
            Dim msg As System.ServiceModel.Channels.Message = System.ServiceModel.Channels.Message.CreateMessage(Me.binding.MessageVersion, info.Action, request, GetContractSerializer(serializerInfo))
            Return Me.getResult(Of TRESPONSE)(Me.getReply(msg), info)
        End Function
        
        Protected Overloads Sub Invoke(Of TREQUEST)(ByVal info As CFInvokeInfo, ByVal request As TREQUEST)
            Dim serializerInfo As CFContractSerializerInfo = New CFContractSerializerInfo
            serializerInfo.MessageContractType = GetType(TREQUEST)
            serializerInfo.IsWrapped = info.RequestIsWrapped
            serializerInfo.ExtraTypes = info.ExtraTypes
            serializerInfo.UseEncoded = info.UseEncoded
            Dim msg As System.ServiceModel.Channels.Message = System.ServiceModel.Channels.Message.CreateMessage(Me.binding.MessageVersion, info.Action, request, GetContractSerializer(serializerInfo))
            If info.IsOneWay Then
                If (Not (Me._outputChannelFactory) Is Nothing) Then
                    Me.postOneWayMessage(msg)
                Else
                    Me.getReply(msg)
                End If
            Else
                Me.processReply(Me.getReply(msg))
            End If
        End Sub
        
        Private Sub postOneWayMessage(ByVal msg As System.ServiceModel.Channels.Message)
            If (Me.OutputChannelFactory Is Nothing) Then
                'transport doesn't support one-way messages
                Throw New System.NotSupportedException
            End If
            Dim outputChannel As System.ServiceModel.Channels.IOutputChannel
            System.Threading.Monitor.Enter(Me.OutputChannelFactory)
            Try 
                outputChannel = Me.OutputChannelFactory.CreateChannel(Me.remoteAddress)
            Finally
                System.Threading.Monitor.Exit(Me.OutputChannelFactory)
            End Try
            outputChannel.Open
            Try 
                outputChannel.Send(msg)
            Finally
                outputChannel.Close
            End Try
        End Sub
        
        Private Function getReply(ByVal msg As System.ServiceModel.Channels.Message) As System.ServiceModel.Channels.Message
            If (Me.RequestChannelFactory Is Nothing) Then
                'transport doesn't support requests
                Throw New System.NotSupportedException
            End If
            Dim requestChannel As System.ServiceModel.Channels.IRequestChannel
            System.Threading.Monitor.Enter(Me.RequestChannelFactory)
            Try 
                requestChannel = Me.RequestChannelFactory.CreateChannel(Me.remoteAddress)
            Finally
                System.Threading.Monitor.Exit(Me.RequestChannelFactory)
            End Try
            requestChannel.Open
            Try 
                Return requestChannel.Request(msg)
            Finally
                If (requestChannel.State = System.ServiceModel.CommunicationState.Opened) Then
                    requestChannel.Close
                End If
            End Try
        End Function
        
        Private Sub processReply(ByVal reply As System.ServiceModel.Channels.Message)
            System.Diagnostics.Debug.Assert((Not (reply) Is Nothing))
            If reply.IsFault Then
                Dim reader As System.Xml.XmlDictionaryReader = reply.GetReaderAtBodyContents
                Try 
                    Throw New CFFaultException(reader.ReadOuterXml)
                Finally
                    reader.Close
                End Try
            End If
        End Sub
        
        Protected Overridable Function GetContractSerializer(ByVal info As CFContractSerializerInfo) As System.Runtime.Serialization.XmlObjectSerializer
            Dim serializer As System.Runtime.Serialization.XmlObjectSerializer
            System.Threading.Monitor.Enter(Me.serializers)
            Try 
                If serializers.ContainsKey(info) Then
                    serializer = Me.serializers(info)
                Else
                    serializer = New CFContractSerializer(info)
                    serializers(info) = serializer
                End If
            Finally
                System.Threading.Monitor.Exit(Me.serializers)
            End Try
            Return serializer
        End Function
        
        Private Function getResult(Of TRESPONSE)(ByVal reply As System.ServiceModel.Channels.Message, ByVal info As CFInvokeInfo) As TRESPONSE
            System.Diagnostics.Debug.Assert((Not (reply) Is Nothing))
            Me.processReply(reply)
            Dim retVal As TRESPONSE = CType(Nothing, TRESPONSE)
            If (reply.IsEmpty = false) Then
                Dim serializerInfo As CFContractSerializerInfo = New CFContractSerializerInfo
                serializerInfo.MessageContractType = GetType(TRESPONSE)
                serializerInfo.IsWrapped = info.ResponseIsWrapped
                serializerInfo.IsResponse = true
                serializerInfo.ExtraTypes = info.ExtraTypes
                serializerInfo.UseEncoded = info.UseEncoded
                retVal = reply.GetBody(Of TRESPONSE)(Me.GetContractSerializer(serializerInfo))
            End If
            Return retVal
        End Function
        
        <System.Diagnostics.DebuggerStepThroughAttribute(),  _
         System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Tools.ServiceModel.NetCFSvcUtil", "3.5.0.0")>  _
        Private Class CFContractSerializer
            Inherits System.Runtime.Serialization.XmlObjectSerializer
            
            Private info As CFContractSerializerInfo
            
            Private serializer As System.Xml.Serialization.XmlSerializer
            
            Private Shared artificialWrapper As System.Xml.XmlQualifiedName = New System.Xml.XmlQualifiedName("wrapper", "")
            
            Public Sub New(ByVal info As CFContractSerializerInfo)
                MyBase.New
                Me.info = info
                If (Me.info.ExtraTypes Is Nothing) Then
                    Me.info.ExtraTypes = New System.Type((0) - 1) {}
                End If
                Me.createSerializer(Nothing)
            End Sub
            
            Private Sub createSerializer(ByVal wrapper As System.Xml.XmlQualifiedName)
                If (wrapper Is Nothing) Then
                    If ((Me.info.IsWrapped = false)  _
                                AndAlso Me.info.IsResponse) Then
                        wrapper = artificialWrapper
                    End If
                End If
                If Me.info.UseEncoded Then
                    Dim [overrides] As System.Xml.Serialization.SoapAttributeOverrides = New System.Xml.Serialization.SoapAttributeOverrides
                    If (Not (wrapper) Is Nothing) Then
                        Dim attributes As System.Xml.Serialization.SoapAttributes = New System.Xml.Serialization.SoapAttributes
                        attributes.SoapType = New System.Xml.Serialization.SoapTypeAttribute(wrapper.Name, wrapper.Namespace)
                        [overrides].Add(Me.info.MessageContractType, attributes)
                    End If
                    Dim soapImporter As System.Xml.Serialization.SoapReflectionImporter = New System.Xml.Serialization.SoapReflectionImporter([overrides], Me.info.DefaultNamespace)
                    Dim i As Integer = 0
                    Do While (i < Me.info.ExtraTypes.Length)
                        soapImporter.IncludeType(Me.info.ExtraTypes(i))
                        i = (i + 1)
                    Loop
                    Dim mapping As System.Xml.Serialization.XmlTypeMapping = soapImporter.ImportTypeMapping(Me.info.MessageContractType)
                    Me.serializer = New System.Xml.Serialization.XmlSerializer(mapping)
                Else
                    Dim rootAttr As System.Xml.Serialization.XmlRootAttribute = Nothing
                    If (Not (wrapper) Is Nothing) Then
                        rootAttr = New System.Xml.Serialization.XmlRootAttribute
                        rootAttr.ElementName = wrapper.Name
                        rootAttr.Namespace = wrapper.Namespace
                    End If
                    Me.serializer = New System.Xml.Serialization.XmlSerializer(Me.info.MessageContractType, Nothing, Me.info.ExtraTypes, rootAttr, Me.info.DefaultNamespace)
                End If
            End Sub
            
            Public Overrides Function IsStartObject(ByVal reader As System.Xml.XmlDictionaryReader) As Boolean
                Throw New System.NotImplementedException
            End Function
            
            Public Overrides Function ReadObject(ByVal reader As System.Xml.XmlDictionaryReader, ByVal verifyObjectName As Boolean) As Object
                If (verifyObjectName = false) Then
                    Throw New System.NotSupportedException
                End If
                If Me.info.IsWrapped Then
                    'Some WSDLs incorrectly advertise their response message namespaces.
                    'Attempt to interop with these by coercing our expected namespace to match.
                    If (Me.serializer.CanDeserialize(reader) = false) Then
                        Me.createSerializer(New System.Xml.XmlQualifiedName(System.Xml.XmlConvert.DecodeName(reader.LocalName), reader.NamespaceURI))
                    End If
                    Return Me.serializer.Deserialize(reader)
                Else
                    Dim ms As System.IO.MemoryStream = New System.IO.MemoryStream
                    Dim settings As System.Xml.XmlWriterSettings = New System.Xml.XmlWriterSettings
                    settings.OmitXmlDeclaration = true
                    Dim innerWriter As System.Xml.XmlWriter = System.Xml.XmlDictionaryWriter.Create(ms, settings)
                    innerWriter.WriteStartElement(artificialWrapper.Name, artificialWrapper.Namespace)
                    Dim commonPrefixes() As String = New String() {"xsi", "xsd"}
                    Dim i As Integer = 0
                    Do While (i < commonPrefixes.Length)
                        Dim ns As String = reader.LookupNamespace(commonPrefixes(i))
                        If (Not (ns) Is Nothing) Then
                            innerWriter.WriteAttributeString("xmlns", commonPrefixes(i), Nothing, ns)
                        End If
                        i = (i + 1)
                    Loop

                    Do While ((reader.NodeType = System.Xml.XmlNodeType.EndElement)  _
                                = false)
                        innerWriter.WriteNode(reader, false)

                    Loop
                    innerWriter.WriteEndElement
                    innerWriter.Close
                    ms.Position = 0
                    Dim innerReader As System.Xml.XmlReader = System.Xml.XmlDictionaryReader.Create(ms)
                    Return Me.serializer.Deserialize(innerReader)
                End If
            End Function
            
            Public Overrides Sub WriteStartObject(ByVal writer As System.Xml.XmlDictionaryWriter, ByVal graph As Object)
                Throw New System.NotImplementedException
            End Sub
            
            Public Overrides Sub WriteObjectContent(ByVal writer As System.Xml.XmlDictionaryWriter, ByVal graph As Object)
                Throw New System.NotImplementedException
            End Sub
            
            Public Overrides Sub WriteEndObject(ByVal writer As System.Xml.XmlDictionaryWriter)
                Throw New System.NotImplementedException
            End Sub
            
            Public Overrides Sub WriteObject(ByVal writer As System.Xml.XmlDictionaryWriter, ByVal graph As Object)
                If Me.info.IsWrapped Then
                    Me.serializer.Serialize(writer, graph)
                Else
                    Dim ms As System.IO.MemoryStream = New System.IO.MemoryStream
                    Dim settings As System.Xml.XmlWriterSettings = New System.Xml.XmlWriterSettings
                    settings.OmitXmlDeclaration = true
                    Dim innerWriter As System.Xml.XmlWriter = System.Xml.XmlDictionaryWriter.Create(ms, settings)
                    Me.serializer.Serialize(innerWriter, graph)
                    innerWriter.Close
                    ms.Position = 0
                    Dim innerReader As System.Xml.XmlReader = System.Xml.XmlDictionaryReader.Create(ms)
                    innerReader.Read
                    writer.WriteAttributes(innerReader, false)
                    If (innerReader.IsEmptyElement = false) Then
                        innerReader.Read

                        Do While ((innerReader.NodeType = System.Xml.XmlNodeType.EndElement)  _
                                    = false)
                            writer.WriteNode(innerReader, false)

                        Loop
                    End If
                    innerReader.Close
                End If
            End Sub
        End Class
        
        Protected Structure CFContractSerializerInfo
            
            Public MessageContractType As System.Type
            
            Public IsWrapped As Boolean
            
            Public IsResponse As Boolean
            
            Public ExtraTypes() As System.Type
            
            Public DefaultNamespace As String
            
            Public UseEncoded As Boolean
        End Structure
        
        Protected Class CFInvokeInfo
            
            Public Action As String
            
            Public ReplyAction As String
            
            Public IsOneWay As Boolean
            
            Public RequestIsWrapped As Boolean
            
            Public ResponseIsWrapped As Boolean
            
            Public ExtraTypes() As System.Type
            
            Public UseEncoded As Boolean
            
            Public Overrides Function Equals(ByVal obj As Object) As Boolean
                If ((Not (obj) Is Nothing)  _
                            AndAlso (obj.GetType Is GetType(CFInvokeInfo))) Then
                    Return (Me.Action = CType(obj,CFInvokeInfo).Action)
                End If
                Return false
            End Function
            
            Public Overrides Function GetHashCode() As Integer
                If (Not (Me.Action) Is Nothing) Then
                    Return Me.Action.GetHashCode
                Else
                    Return MyBase.GetHashCode
                End If
            End Function
        End Class
    End Class
    
    Public Class CFFaultException
        Inherits System.ServiceModel.CommunicationException
        
        Private _faultMessage As String
        
        Public Sub New(ByVal faultMessage As String)
            MyBase.New
            Me._faultMessage = faultMessage
        End Sub
        
        Public ReadOnly Property FaultMessage() As String
            Get
                Return Me._faultMessage
            End Get
        End Property
    End Class
End Namespace
